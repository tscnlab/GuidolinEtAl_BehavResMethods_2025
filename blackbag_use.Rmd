---
title: "blackbag_use"
author: "Carolina Guidolin"
date: "2024-05-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Use of black bag (low illuminance values) to detect non-wear time

Here we analyse data from black bag use (low illuminance [mEDI] values). The first thing that we want to do is a visual inspection of the data to check how light and activity compare, for each State of the Wear log. Low activity is also often used as a way to understand non-wear time in field studies. Since we have both information (light and activity), we want to know how these two source compare to each other. 

```{r}
#We will be plotting using log10 transformation, so we want to replace 0 values for mEDI (light) and PIM (activity) to very low values

dataset.LL.wrlg$MEDI[dataset.LL.wrlg$MEDI == 0] <- 0.00001
dataset.LL.wrlg$PIM[dataset.LL.wrlg$PIM == 0] <- 0.00001

#TO be able to visually observe how light and activity relate to each other in our dataset, we cannot plot all our datapoints (too many). So, we take median values of each Id, for each State (off/on/sleep)

median.LL.wrlg <- dataset.LL.wrlg %>%
  group_by(Id, State) %>%
  summarise(median_medi = median(log10(MEDI), na.rm = TRUE),
            median_pim = median(log10(PIM), na.rm = TRUE),
            qr1_medi = quantile(log10(MEDI), 1/4, na.rm = TRUE), #first quantile
            qr1_pim = quantile(log10(PIM), 1/4, na.rm = TRUE), #first quantile
            qr3_medi = quantile(log10(MEDI), 3/4, na.rm = TRUE), #third quantile
            qr3_pim = quantile(log10(PIM), 3/4, na.rm = TRUE)) %>% #third quantile
  ungroup()

#Let's create a simple scatterplot where median mEDI and PIM are plotted against each other, including error bars
median_scatter <- 
  ggplot(median.LL.wrlg, aes(x = median_medi, y = median_pim, color = State, fill = State)) +
  geom_point() +
    #position = position_jitter(width = 0.5, height = 0.5)) 
 # xlim(-5, 2.5) +
 # ylim(0, 750) +
  scale_fill_manual(
    values = c("off" = "#16439C", "on" = "palegreen4", "sleep" = "darkgoldenrod2")) +
  scale_color_manual(
    values = c("off" = "#16439C", "on" = "palegreen4", "sleep" = "darkgoldenrod2")) +
  labs(title = "Relationship between light and activity", x = "mEDI", y = "PIM") +
  geom_errorbar(aes(ymin = qr1_pim, ymax = qr3_pim)) +
  geom_errorbarh(aes(xmin = qr1_medi, xmax = qr3_medi)) +
  theme_minimal() +
  scale_x_continuous(transform = "symlog")
1
#For the states sleep and off, there are a lot of overlapping points, which is why only a few points are shows. While this plot shows that we have a lot of variability, especially in PIM, we can't really say much about the individual datapoints. 

```


```{r}
#To improve the visualisation above, we can create a simple scatterplot without error bars, and add boxplots as marginal plots

scatter <- ggplot(median.LL.wrlg, aes(x = median_medi, y = median_pim)) + 
  geom_jitter(aes(fill = State, color = State), size = 2.5, alpha = 0.6,
              position = position_jitter(width = .3, height = .3)) + #adjust position of points to avoid overlap
   scale_fill_manual(
    name = "Wear log \n'state'",
    values = c("off" = "#0072B2", "on" = "darkred", "sleep" = "darkgoldenrod2"),
    labels = c("Wake 'off'", "Wake 'on'", "Sleep 'off'")) +
  scale_color_manual(
    name = "Wear log \n'state'",
    values = c("off" = "#0072B2", "on" = "darkred", "sleep" = "darkgoldenrod2"),
    labels = c("Wake 'off'", "Wake 'on'", "Sleep 'off'")) +
  scale_x_continuous(
    breaks = c(-5, -3, -1, 1, 3), 
    labels = c(expression(10^-5), expression(10^-3), expression(10^-1), expression(10^1), expression(10^3)), #ensure that the log expression is labelled correctly 
    limits = c(-5.5, 3)
  ) +
  scale_y_continuous(
    breaks = c(-5, -3, -1, 1, 3),
    labels = c(expression(10^-5), expression(10^-3), expression(10^-1), expression(10^1), expression(10^3)), #ensure that the log expression is labelled correctly 
    limits = c(-5.5, 3)
  ) +
  labs(x = "Median illuminance (mEDI, lx)",
       y = "Activity (PIM)") +
  coord_fixed(ratio=1) + #make sure plot is a square
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.title = element_text(size = 12, hjust = 0.5),
        legend.text = element_text(size = 12),
        legend.position = "bottom") +
  guides(fill = guide_legend(nrow = 1))
  
#Add a boxpot as a marginal plot using package ggExtra
library(ggExtra)

marginal <- ggExtra::ggMarginal(scatter, type = "boxplot", groupColour = TRUE, groupFill = TRUE)


plot_marginal <- annotate_figure(marginal,
                                 #Add title
                                 top = text_grob("Relationship between illuminance \nand activity across wear log states",
                                                            color = "black",
                                                            face = "plain",
                                                            size = 18))

ggsave(filename = "plot_marginal.png",
       plot = plot_marginal ,
       width = 5,
       height = 6.5,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs")

```



```{r}
#Another alternative visualisation would be to simply plot mEDI, without activity, across the Wear log states
library(ggdist)

ggplot(data = median.LL.wrlg, aes(x=median_medi, y = State, fill = State)) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    justification = -.25,
    point_color = NA,
    interval_color = NA
    ) +
  geom_boxplot(
    aes(color = State),
    width = .3,
    alpha = .2,
    outlier.shape = NA
  ) +
  geom_jitter(
    aes(colour = State),
    fill = "white",
    height = .1,
    alpha = .3,
    size = 1.2
  ) +
  scale_fill_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_color_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_y_discrete(labels = c("on" = "Wake 'on'", "off" = "Wake 'off'", "sleep" = "Sleep 'off'")) +
  theme_ggdist() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
 # ggpubr::rremove("xlab")+ 
  labs(title = "(Non-)wear time distribution across the week", x = "Illuminance (mEDI, lx)") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 20),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16))

#This does not seem to work very well, probably because our sample has too many duplicates of low values 

```

##Testing steffen's function which indentifies clusters of non-wear time 
These functions (find_clusters_funs, loaded in separately) identify clusters of low illuminance. The following parameters can be selected: 
1) logical values where clusters should be found - in this case, low illuminance values (below a certain threshold)
2) minimum length of the clusters
3) max interrpution length for the cluster to still be identified as such 
```{r}

medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
roc_medi_list <- list()

for (threshold in medithresholds) {

medi_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = "2 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


mediclusters_clean <- medi_clusters %>%
  select(Id, Datetime, State, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    )) 

#We want to build a Receiver Operating Curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

mediclusters_clean <- mediclusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

roc_medi <- mediclusters_clean %>%
  group_by(classification) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
  mutate(TPR = TP/(TP+FN), #this is the formula for TPR (true positive rate)
         FPR = FP/(FP+TN), #this is the formula for the FPR (false positive rate)
         PPV = TP/(TP+FP),
         NPV = TN/(FN+TN),
         threshold = threshold)  #adding manually which mEDI threshold I am considering here 
 # select(TPR, FPR, threshold)


 #Add the result to the list
  roc_medi_list[[as.character(threshold)]] <- roc_medi
}

#Turn the list with the results into a df 
total_roc <- bind_rows(roc_medi_list)

#Turn thresholds from character to factor for plotting
total_roc$threshold <- as.numeric(total_roc$threshold)

#Plot ROC: FPR on x axis, TPR on y axis
#create a colour palette with n=20 colours
palette <- hcl.colors(palette = "viridis", n = 10)

roc_medi <- ggplot(total_roc, aes(x = FPR, y = TPR, color = threshold)) +
  geom_point() +
 # geom_smooth() +
  xlim(0,1) + 
  ylim(0,1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "darkgrey") + #add a 45 degree line 
  #scale_color_manual(
 #   values = palette,
   # labels = c(#"0.5" = "mEDI < 0.5 lx",
            #   "1" = "mEDI < 1 lx",
              # "1.5"= "mEDI < 1.5 lx",
            #   "2" = "mEDI < 2 lx",
              # "2.5" = "mEDI < 2.5 lx",
            #   "3" = "mEDI < 3 lx",
              # "3.5" = "mEDI < 3.5 lx",
            #   "4" = "mEDI < 4 lx",
              # "4.5" = "mEDI < 4.5 lx",
             #  "5" = "mEDI < 5 lx",
              # "5.5" = "mEDI < 5.5 lx",
             #  "6" = "mEDI < 6 lx",
             #  "6.5" = "mEDI < 6.5 lx",
           #    "7" = "mEDI < 7 lx",
             #  "7.5" = "mEDI < 7.5 lx",
           #    "8" = "mEDI < 8 lx",
              # "8.5" = "mEDI < 8.5 lx",
           #    "9" = "mEDI < 9 lx",
              # "9.5" = "mEDI < 9.5 lx",
           #    "10" = "mEDI < 10 lx")) +
  labs(x="FPR",
       y = "True positive rate",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds") +
  guides(color = guide_legend(title = "mEDI threshold")) +
  theme_bw() +
  coord_fixed(ratio = 1)

```

```{r}
library(plotROC)
library(pROC)

medi10lux_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < 10) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = "2 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


medi10lux_clusters_clean <- medi10lux_clusters %>%
  select(Id, Datetime, State, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    ))

#We want to build a Receiver Operating Curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 0), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

medi10lux_clusters_clean <- medi10lux_clusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

roc_10medi <- medi10lux_clusters_clean %>%
  group_by(classification) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count) %>%
  mutate(TPR = TP/(TP+FN),
         FPR = FP/(FP+TN),
         PPV = TP/(TP+FP),
         NPV = TN/(FN+TN),
         threshold = threshold)  #adding manually which mEDI threshold I am considering here 
#  select(TPR, FPR, threshold) %>%
      


roc_curve10 <- roc(data = medi10lux_clusters_clean,
                  response = is_low_medi_cluster,
                  predictor = State,
                  levels = c(control = 1, case = 0))

ggroc(roc_curve10)

```


```{r}
generate_roc_medi <- function(dataset, low_medi_var, min_length, max_interrupt, medi_threshold) {
  medi_clusters <- dataset %>%
    ungroup() %>%
    filter(!State == "sleep") %>%
    mutate(low_medi = !!rlang::sym(low_medi_var) < medi_threshold) %>%
    nest_by(Id) %>%
    mutate(
      data = list(
        data_find_clusters(
          data, 
          low_medi, 
          min_length = min_length, 
          max_interrupt = max_interrupt, 
          cluster_name = "low_medi_cluster"
        )
      )
    ) %>%
    unnest(cols = data) %>%
    ungroup()
  
  mediclusters_clean <- medi_clusters %>%
    select(Id, Datetime, State, is_low_medi_cluster) %>%
    mutate(
      State = case_when(
        State == "on" ~ 1, 
        State == "off" ~ 0),
      is_low_medi_cluster = case_when(
        is_low_medi_cluster == TRUE ~ 0,
        is_low_medi_cluster == FALSE ~ 1
      )
    )
  
  mediclusters_clean <- mediclusters_clean %>%
    mutate(classification = case_when(
      State == 0 & is_low_medi_cluster == 0 ~ "TP",
      State == 0 & is_low_medi_cluster == 1 ~ "FN",
      State == 1 & is_low_medi_cluster == 0 ~ "FP",
      State == 1 & is_low_medi_cluster == 1 ~ "TN",
      .default = NA_character_
    ))
  
  roc_medi <- mediclusters_clean %>%
    group_by(classification) %>%
    summarise(count = n()) %>%
    pivot_wider(names_from = classification, values_from = count, values_fill = list(count = 0)) %>%
    mutate(
      TPR = TP / (TP + FN),
      FPR = FP / (FP + TN),
      PPV = TP / (TP + FP),
      NPV = TN / (FN + TN),
      max_interrupt = max_interrupt #note: this has to be changed every time based on which variable you are varying
    )
  
  return(roc_medi)
}


```


#Now, we vary one parameter: mEDI values 
```{r}
# Step 1: vary mEDI thresholds
thresholds <- seq(1, 10, by = 1)
roc_medi <- map(thresholds, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = "2 mins",
  max_interrupt = "1 mins",
  medi_threshold = .x
))

names(roc_medi) <- as.character(thresholds)
roc_medi <- bind_rows(roc_medi)


ggplot(roc_medi, aes(x = FPR, y = TPR)) +
  geom_point(aes(color = medi_threshold)) +
  xlim(0,1) + 
  ylim(0,1) +
  scale_color_continuous(
    limits= c(1,10), breaks = c(2, 4, 6, 8, 10)
  ) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "darkgrey") + #add a 45 degree line 
  labs(x="False positive rate",
       y = "True positive rate",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds") +
  guides(
    color = guide_colorbar(
    title = "mEDI threshold (lx)",
    nbin = 10,
    reverse = TRUE)) +
  theme_bw() +
  coord_fixed(ratio = 1)


```




```{r}
# Step 2: vary length of interval 
min_lengths <- paste0(seq(1, 10, by = 1), " min")
roc_minlength <- map(min_lengths, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = .x,
  max_interrupt = "1 mins",
  medi_threshold = 4
))

names(roc_minlength) <- min_lengths
roc_minlength <- bind_rows(roc_minlength)

ggplot(roc_minlength, aes(x = FPR, y = TPR)) +
  geom_point(aes(color = min_length)) +
  xlim(0,1) + 
  ylim(0,1) +
 # scale_color_continuous(
 # limits= c(1,10), breaks = c(2, 4, 6, 8, 10)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "darkgrey") + #add a 45 degree line 
  labs(x="False positive rate",
       y = "True positive rate",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds") +
  theme_legend(
  #  color = guide_colorbar(
    title = "Min. length"
  #  nbin = 10,
  #  reverse = TRUE
  ) +
  theme_bw() +
  coord_fixed(ratio = 1)
```

```{r}
# Step 3: vary max interruption length 
max_interrupt <- paste0(seq(1, 10, by = 1), " min")
roc_max_interrupt<- map(max_interrupt, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = "2 mins",
  max_interrupt = .x,
  medi_threshold = 4
))

names(roc_max_interrupt) <- max_intlengths
roc_max_interrupt <- bind_rows(roc_max_interrupt)

ggplot(roc_max_interrupt, aes(x = FPR, y = TPR)) +
  geom_point(aes(color = max_interrupt)) +
  xlim(0,1) + 
  ylim(0,1) +
 # scale_color_continuous(
  #limits= c(1,10), breaks = c(2, 4, 6, 8, 10)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "darkgrey") + #add a 45 degree line 
  labs(x="False positive rate",
       y = "True positive rate",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds") +
 # guides(
  #  color = guide_colorbar(
  #  title = "Max. interrupt (mins)",
  #  nbin = 10,
   # reverse = TRUE)) +
  theme_bw() +
  coord_fixed(ratio = 1)

```


