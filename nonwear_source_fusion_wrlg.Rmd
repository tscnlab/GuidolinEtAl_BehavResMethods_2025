---
title: "nonwear_source_fusion"
author: "Carolina Guidolin"
date: "2023-11-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Backgorund
The aim is to describe and compare strategies for tracking non-wear time of wearable light loggers used in ambulatory light exposure studies. This can help other researchers to plan their experiments and choose a non-wear time strategy which fits their research requirements. 

##Dataset description
Participants N = 26
Duration: 7 full days
Wearable device: ActLumus with 10 seconds sampling period, worn on spectacles ("light glasses")

Non-wear time information is given by three sources:  
1. Wear log completed by the participant with following information: 
  - Timestamp of taking the light glasses off (current/retrospective) 
  - Timestamp of placing the light glasses back on (current/retrospective) 
  - Timestamp of taking the light glasses off before bed (current/retrospective) 
  - Use of black bag during non-wear episode (current/retrospective) 

2. Button presses done by the participant (logged by ActLumus); 

3. Light while in black bag (mEDI ≤1 lux during non-wear time) 
  - Note: this is partly related to the Wear log, as information on whether the black bag was used or not is contained in the Wear log 

Each of these three sources can be used individually to detect a non-wear period. However, the Wear log entries were monitored twice a day by the experimenter, and thus considered as the “ground truth” for non-wear detection. 

## Research question
The ovearching RQ is: What is the concordance between different sources of non-wear?

##Data fusion 
To answer the RQ, we first need to integrate the data coming from these three sources. We will do this in a LightLogR native format, as in the future we might want to have these functions built in LightLogR.

###Load in the necessary packages
```{r}
library(tidyverse)
library(hms)
library(here)
library(scales)
library(lubridate)
library(LightLogR)
library(ggpubr)
library(ggbreak)
```


### Loading actlumus data 
First, we need to import the ActLumus file where the button press information is contained. We will need this later.
```{r}
Sys.setlocale("LC_TIME", "en_US.UTF-8") #needed to run this code to have the days displayed in English and not German

path <- "G:/cyepi/code/pre-processing/nonwear_detection/actlumus"
tz <- "Europe/Berlin"

# Get a list of file paths in the specified directory
actlumusfiles <- list.files(path, pattern = ".txt", full.names = TRUE)

# Create an empty dataframe to store the combined data
dataset.LL.all <- data.frame()

# Iterate over each file and import data
# Ensure that the datasets crossing from DST to ST on 29.10.2023 are adjusted for using dst_adjustment function 
dataset.LL.all <- import$ActLumus(actlumusfiles, tz = tz, auto.id = "^(\\d{3})", dst_adjustment = TRUE)

```

Every participant started at different times. We will have to specify start and end time manually. 
Start times are taken as the first timestamp when the participant started the study. This is reported in the Wear log.
End times are taken as the timestamp of "putting the light glasses back on" on the morning of the last day of the experiment, i.e. when participants had to return to the laboratory. In case this was missing, "data"out of bed" data from the sleep diary was used (this was the case for 4 participants), as this would be the closest approximation. For one participant (213), the data from the sleep diary was missing as well. Thus, the end time was determined as midnight of the last experimental day (Sunday).


```{r}
filtered_time <- data.frame(
  Id = c("201", "202", "204", "205", "206", "208", "209", "210", "212", "213", "214", "215", "216", "218", "219", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231"),
  start = as.POSIXct(c("2023-08-14 12:40:00", #201
                       "2023-08-14 13:26:00", #202
                       "2023-08-14 14:43:00", #204
                       "2023-08-28 15:42:00", #205
                       "2023-08-28 14:16:00", #206
                       "2023-09-04 12:36:00", #208
                       "2023-09-04 14:01:00", #209
                       "2023-09-04 15:20:00", #210
                       "2023-09-11 13:03:00", #212
                       "2023-09-11 15:06:00", #213
                       "2023-09-25 14:56:00", #214
                       "2023-10-02 11:30:00", #215
                       "2023-10-02 14:31:00", #216
                       "2023-10-16 11:18:00", #218
                       "2023-10-16 12:40:00", #219
                       "2023-10-23 11:22:00", #221
                       "2023-10-23 13:10:00", #222
                       "2023-10-30 11:34:00", #223
                       "2023-10-30 13:24:00", #224
                       "2023-10-30 15:05:00", #225
                       "2023-10-30 16:34:00", #226
                       "2023-10-30 17:44:00", #227
                       "2023-11-06 11:02:00", #228
                       "2023-11-06 12:34:00", #229
                       "2023-11-06 14:02:00", #230
                       "2023-11-06 17:12:00"  #231
                       )),    # Add start times
  end = as.POSIXct(c("2023-08-21 07:31:00", #201
                     "2023-08-21 07:23:00", #202
                     "2023-08-21 08:59:00", #204
                     "2023-09-04 07:28:00", #205
                     "2023-09-04 08:08:00", #206
                     "2023-09-11 07:30:00", #208
                     "2023-09-11 07:45:00", #209
                     "2023-09-11 06:16:00", #210 from sleep diary, out_ofbed
                     "2023-09-18 06:01:00", #212 
                     "2023-09-17 23:59:59", #213 midnight of previous day, because of missing data on final day 
                     "2023-10-02 09:02:00", #214
                     "2023-10-09 08:27:00", #215
                     "2023-10-09 11:01:00", #216
                     "2023-10-23 08:13:00", #218
                     "2023-10-23 07:10:00", #219 from sleep diary, out_ofbed
                     "2023-10-30 07:58:00", #221
                     "2023-10-30 08:18:00", #222
                     "2023-11-06 08:00:00", #223
                     "2023-11-06 08:23:00", #224
                     "2023-11-06 05:44:00", #225 from sleep diary, out_ofbed
                     "2023-11-06 06:49:00", #226
                     "2023-11-06 07:07:00", #227
                     "2023-11-13 07:49:00", #228
                     "2023-11-13 07:09:00", #229
                     "2023-11-13 08:02:00", #230 from sleep diary, out_ofbed
                     "2023-11-13 08:15:00" #231
                     ))# Add end times
)

#Adjust the dataset 
dataset.LL.all <- dataset.LL.all %>%
  inner_join(filtered_time, by = "Id") %>%
  filter(Datetime >= start, Datetime <= end) %>%
  select(-start, -end)

```

### Loading Wear log files 

First, we need to import the data from the wear log
```{r}
filepath <- here("G:/cyepi/code/pre-processing/nonwear_detection/wearlog")

# Get the files names from directory
wearlogfiles = list.files(filepath, pattern="*.csv", full.names = TRUE)

```

### Non-wear time according to the Wear log (1st source of non-wear)
Here we create States (using import_Statechanges) that code for the 3 most important information contained in the Wear log: 1. When the light glasses were on, 2. When the light glasses were off, 3. When the light glasses were put off for sleep. Retrospective and real-time information are treated as equal for this step. 
```{r pressure, echo=FALSE}
wearlog_entries_raw <- 
  #filenames:
  wearlogfiles %>% 
  #import_Statechanges from LightLogR to create states based on timestamps
  LightLogR::import_Statechanges(
    sep = ";", dec = ",", Datetime.format = "dmyHM", tz = "Europe/Berlin", 
    Id.colname = record_id,
    State.colnames = 
      c("wearlog_on", "wearlog_off", "wearlog_past_on", "wearlog_past_off", "wearlog_bed", "wearlog_past_sleep"),
    State.encoding = 
      c("1", "0", "1", "0", "2", "2") #off coded as 0, on coded as 1, sleep coded as 2
    ) 

```

###Quality check 1a: Identifying consecutive datetimes
The first thing that we want to check is for identical consecutive timestamps, i.e. identical and consecutive Datetime values. These should not occur, but it is possible that something went "wrong" from the participants' side. If this is the case, it should be corrected. 
```{r}
error_messages_datetime <- character(0) # We create an empty vector where we can store the errors

wearlog_entries_raw %>%
  group_by(Id) %>%
  arrange(Datetime) %>%  # Ensure data is sorted by Datetime
  mutate(PrevDatetime = lag(Datetime)) %>%
  filter(Datetime == PrevDatetime) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(error_message = paste("Consecutive timestamps at record_id:", Id, "datetime:", Datetime)) %>%
  pull(error_message) -> error_messages_datetime

# Check if there are error messages
if (length(error_messages_datetime) > 0) {
  # There are errors; print the error messages
  for (error_message in error_messages_datetime) {
    cat("Error:", error_message, "\n")
  }
} else {
  cat("No consecutive value errors found.")
}
```

###Quality check1b: Correcting the identified problematic entries 
For each of the identified entries, the raw file was checked and the erraneous entry was corrected according to the specifications reported below. 
```{r}
#1Error: Consecutive timestamps at record_id: 202 datetime: 2023-08-14 16:42:00, wearlog_on (1) - participant accidentally entered previous datetime, rather than current one (the app defaults to the previous datetime, so the participant has to detect this and correct it). Correct value can be taken from start_date column: 14-08-2023 17:11:00

corrected_202datetime_on <- as.POSIXct("2023-08-14 17:11:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wearlog_entries_raw %>%
  mutate(
    Datetime = if_else(Id == "202" & Datetime == "2023-08-14 16:42:00" & State == 1, corrected_202datetime_on, Datetime))

#2Error: Consecutive timestamps at record_id: 202 datetime: 2023-08-14 22:22:00 wearlog_on (1) - participant accidentally entered previous datetime, rather than current one (the app defaults to the previous datetime, so the participant has to detect this and correct it). Correct value can be taken from start_date column: 15-08-2023 07:47:00

corrected_202datetime_on1 <- as.POSIXct("2023-08-15 07:47:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "202" & Datetime == "2023-08-14 22:22:00" & State == 1, corrected_202datetime_on1, Datetime)) %>%
  filter(!(Id == "202" & Datetime == "2023-08-14 22:21:00" & State == 0)) # We noticed that the participant forgot that the "sleep" option existed, so they logged wearlog_off when going to bed. One minute after they remember and then logged it as wearlog_sleep. So we will eliminate this wearlog_off entry, since it is redundant with the following wearlog_sleep entry. 


#3Error: Consecutive timestamps at record_id: 201 datetime: 2023-08-17 06:51:00 wearlog_off (0) - participant wore the light logger for less than 1 minute, and then placed it in the black bag. To adjust for this, we will add 1 minute to the wear log entry: 2023-08-17 06:52:00

corrected_201datetime_off <- as.POSIXct("2023-08-17 06:52:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "201" & Datetime == "2023-08-17 06:51:00" & State == 0, corrected_201datetime_off, Datetime))


#4Error: Consecutive timestamps at record_id: 201 datetime: 2023-08-17 17:40:00 wearlog_on (1) - participant accidentally entered incorrect datetime. Correct value can be taken from start_date column: 17-08-2023 11:40:00

corrected_201datetime_off1 <- as.POSIXct("2023-08-17 11:40:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "201" & Datetime == "2023-08-17 17:40:00" & State == 1, corrected_201datetime_off1, Datetime))

#5Error: Consecutive timestamps at record_id: 201 datetime: 2023-08-20 11:19:00 wearlog_bed (2) - participant accidentally entered incorrect datetime. Correct value can be taken from start_date column: 2023-08-20 01:11:00

corrected_201datetime_bed <- as.POSIXct("2023-08-20 01:11:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "201" & Datetime == "2023-08-20 11:19:00" & State == 2, corrected_201datetime_bed, Datetime))


#6Error: Consecutive timestamps at record_id: 205 datetime: 2023-08-28 15:42:00 wearlog_on (1) - first entry for participant was accidentally entered twice. One of them should be removed. 
wrlg_entries <- wrlg_entries %>%
  group_by(Id) %>%
  filter(!(Id == "205" & row_number() == 1)) %>%
  ungroup()


#7Error: Consecutive timestamps at record_id: 208 datetime: 2023-09-08 07:33:00 wearlog_on (1) - entry for participant was accidentally entered twice. One of them should be removed. 

participant_id <- "208"
duplicate_datetime <- as.POSIXct("2023-09-08 07:33:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)
duplicate_state <- 1

wrlg_entries <- wrlg_entries %>%
  group_by(Id) %>%
  mutate(duplicate_flag = cumsum(Id == participant_id & Datetime == duplicate_datetime & State == duplicate_state)) %>% #creating a second column which will have value of 2 if a duplicate occurs
  filter(!(Id == participant_id & Datetime == duplicate_datetime & State == duplicate_state & duplicate_flag == 2)) %>% #filters out second occurrence of the entry
  select(-duplicate_flag) %>% #removes extra column
  ungroup()


#8Error: Consecutive timestamps at record_id: 214 datetime: 2023-09-26 23:15:00 wearlog off (0) - entry for participant was accidentally entered twice. The second one is a wearlog_bed entry, which participant specified being the correct one in email exchange. This, the wearlog_off entry should be removed. 

wrlg_entries <- wrlg_entries%>%
  filter(!(Id == "214" & Datetime == "2023-09-26 23:15:00" & State == 0))
```

###Summary of the rules used to adjust for identical consecutive datetimes
1) If consecutive identical datetime, but different States, and start_date different than datetime, then take info from start_date [this is an automated timestamp from the app]
2) If consecutive identical datetime, and same States, and timestamp from start_date is equal to the timestamp from datetime, then keep the first one [second entry considered accidental]
3) If consecutive identical datetime, but different States, and timestamp from start_date is equal to timestamp from datetime, and consecutive value suggests it is a wrong entry = adjust accordingly (see solution 3 and 8), with the help of visual inspection 

###Quality check 1c: verifying that the quality check worked. We apply the same code, with the refined dataset. Expected result is that we do not see any consecutive datetime values.
```{r}
error_messages_datetime <- character(0) # We create an empty vector where we can store the errors

wrlg_entries %>%
  group_by(Id) %>%
  arrange(Datetime) %>%  # Ensure data is sorted by Datetime
  mutate(PrevDatetime = lag(Datetime)) %>%
  filter(Datetime == PrevDatetime) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(error_message = paste("Consecutive timestamps at record_id:", Id, "datetime:", Datetime)) %>%
  pull(error_message) -> error_messages_datetime

# Check if there are error messages
if (length(error_messages_datetime) > 0) {
  # There are errors; print the error messages
  for (error_message in error_messages_datetime) {
    cat("Error:", error_message, "\n")
  }
} else {
  cat("No consecutive value errors found.")
}

#No consecutive values found. Great!
```
###Quality check 2a: Identifying consecutive States
The second thing that we want to check is for identical consecutive States, i.e. identical and consecutive entries in the State column. This would not make sense.
```{r}
error_messages_states <- character(0) # We create an empty vector where we can store the errors

# Group by ID and then apply the quality check within each group
wrlg_entries %>%
  group_by(Id) %>%
  arrange(Datetime) %>%  # Ensure data is sorted by Datetime
  mutate(PrevState = lag(State)) %>%
  filter(State == PrevState) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(error_message = paste("Consecutive values at record_id:", Id, "datetime:", Datetime, "state:", State)) %>%
  pull(error_message) -> error_messages_states

# Check if there are error messages
if (length(error_messages_states) > 0) {
  # There are errors; print the error messages
  for (error_message in error_messages_states) {
    cat("Error:", error_message, "\n")
  }
} else {
  cat("No consecutive value errors found.")
}
```
###Quality check 2b: fixing the consecuitve State entries found above
```{r}
#1Error: Consecutive values at record_id: 202 datetime: 2023-08-15 07:47:00 state: 1 
#1Solution: This is the same entry that caused issues in the Datetime. We had changed it above to a "wearlog_on" entry, which appears to be the first entry after wake up. Since I had not noticed the consecutive datetime error above, I had asked the participant to make a retrospective entry, as I thought that this wearlog_on entry was missing. Now, we eliminate the retrospective entry since we have found the original "current" entry, on the basis that the restropsective entry would be less accurate. 

wrlg_entries <- wrlg_entries %>%
  filter(!(Id == "202" & Datetime == "2023-08-15 07:47:00" & State == 1))

#2Error: Consecutive values at record_id: 201 datetime: 2023-08-18 19:54:00 state: 0. 
#2Solution: This should be a wearlog_on entry. We assume this because of two reasons: 1) visual inspection of light and activity suggests a wear interval between 19:54 and 20:14, and 2) this wearlog_off entry is located between two wearlog_off entries, which suggests that the participant accidentally logged this one as an "off" as well. 

correct_state201 <- "1"
wrlg_entries <- wrlg_entries %>%
  mutate(
    State = if_else(Id == "201" & Datetime == "2023-08-18 19:54:00" & State == 0, correct_state201, State))


#3Error: Consecutive values at record_id: 201 datetime: 2023-08-18 20:14:00 state: 0 
#3solution: this has been fixed with the solution above (#2solution)

#4Error: Consecutive values at record_id: 202 datetime: 2023-08-18 22:29:00 state: 2 
#4Solution: This is missing data: the participant did not report any other entry on that day, so the previous entry is the "wearlog_bed" from the night before. To obtain a "wearlog_entry" for this participant, we insert the timestamp from the sleep diary, namely from the column "out_ofbed"

newrow_202 <- data.frame(
  Id = as.factor(202),
  State = as.character(1),
  Datetime = as.POSIXct("2023-08-18 06:37:00", tz = tz)
)

wrlg_entries <- bind_rows(wrlg_entries, newrow_202) %>%
  arrange(Id, Datetime)


#5Error: Consecutive values at record_id: 205 datetime: 2023-09-02 16:47:00 state: 1
#5Solution: This should be a wearlog_off entry. We assume this because of two reasons: 1) visual inspection of light and activity suggests a non-wear interval between 16:47 and  17:10, and 2) this wearlog_onentry is located between two wearlog_on entries, which suggests that the participant accidentally logged this one as an "on" as well. 

correct_state205 <- "0"
wrlg_entries <- wrlg_entries %>%
  mutate(
    State = if_else(Id == "205" & Datetime == "2023-09-02 16:47:00" & State == 1, correct_state205, State))  

#6Error: Consecutive values at record_id: 205 datetime: 2023-09-02 17:10:00 state: 1 
#6Solution: this has been fixed with the solution above (#5solution)

#7Error: Consecutive values at record_id: 205 datetime: 2023-09-03 09:40:00 state: 1 
#7Solution. After visually inspecting the raw light and activity data, as well as looking at the wear log entries, we conclude that this entry is correct. However, there is a problem with the previous entry: record_id: 205 datetime: 2023-09-03 08:40:00 state: 1. It looks like two entries were logged at the same time, which should not be possible in the app. We don't know how this happened, but we will adjust the entries as follows:
#1) 2023-09-03 08:47:00 wearlog_on should be turned into 2023-09-03 08:40:00 wearlog_on 
#2) 2023-09-03 08:40:00 wearlog_on should be turned into 2023-09-03 08:47:00 wearlog_off
#3) 2023-09-03 09:40:00 wearlog_off  should be left as is

#1)
correct_state205_1 <- "1"
wrlg_entries <- wrlg_entries %>%
  mutate(
    State = if_else(Id == "205" & Datetime == "2023-09-03 08:40:00" & State == 0, correct_state205_1, State))  

#2)
correct_state205_2 <- "0"

wrlg_entries <- wrlg_entries %>%
  mutate(
    State = if_else(Id == "205" & Datetime == "2023-09-03 08:47:00" & State == 1, correct_state205_2, State)
  )

#8Error: Consecutive values at record_id: 209 datetime: 2023-09-08 00:58:00 state: 2 
#8Solution: strangely, the participant thought that they had not logged this, and so they logged it retrospectively again on the following day. We keep the original entry and eliminate this one. 
wrlg_entries <- wrlg_entries %>%
  filter(!(Id == "209" & Datetime == "2023-09-08 00:30:00" & State == 2))

#9Error: Consecutive values at record_id: 215 datetime: 2023-10-03 08:33:00 state: 1 
#9Solution: the participant accidentally entered the previous date (2023-10-03) instead of the current date (2023-10-04). We can change this manually
correct_date_215 <- as.POSIXct("2023-10-04 08:33:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)

wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "215" & Datetime == "2023-10-03 08:33:00" & State == 1, correct_date_215, Datetime )
  )

#10Error: Consecutive values at record_id: 215 datetime: 2023-10-07 01:15:00 state: 2 
#10Solution: the participant forgot to update the date to the next day, since the timestamp is after midnight.
correct_date_215_2 <- as.POSIXct("2023-10-08 01:15:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)
wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "215" & Datetime == "2023-10-07 01:15:00" & State == 2, correct_date_215_2, Datetime )
  )

#11Error: Consecutive values at record_id: 215 datetime: 2023-10-07 16:50:00 state: 1 
#11Solution: We do not know why this participant entered this wearlog_on retrospectively. Since there is no strong evidence from visual inspection of light and activity data that they are not wearing the device, we eliminate this entry and keep the previous wearlog_on entry at 12:22

wrlg_entries <- wrlg_entries %>%
  filter(!(Id == "215" & Datetime == " 2023-10-07 16:50:00" & State == 1))

#12Error: Consecutive values at record_id: 218 datetime: 2023-10-21 02:15:00 state: 2 
#12Solution: the participant forgot to update the date to the next day, since the timestamp is after midnight
correct_date_218 <- as.POSIXct("2023-10-22 02:15:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)
wrlg_entries <- wrlg_entries %>%
  mutate(
    Datetime = if_else(Id == "218" & Datetime == "2023-10-21 02:15:00" & State == 2, correct_date_218, Datetime )
  )

#13Error: Consecutive values at record_id: 218 datetime: 2023-10-22 11:00:00 state: 1 
#13Solution: this has now been solved with the solution above (#12solution)

#14Error: Consecutive values at record_id: 218 datetime: 2023-10-23 08:22:00 state: 1 
#14Solution: this is the last day of participation for this individual. We will only keep the first entry anyways, so we can eliminate this second entry which we would not use anyways (and is redudant) - without caring about what the participant actually wanted to log

wrlg_entries <- wrlg_entries %>%
  filter(!(Id == "218" & Datetime == "2023-10-23 08:22:00" & State == 1))

```

#Quality check 2c: checking that our data cleaning worked 
```{r}
error_messages_states <- character(0) # We create an empty vector where we can store the errors

# Group by ID and then apply the quality check within each group
wrlg_entries %>%
  group_by(Id) %>%
  arrange(Datetime) %>%  # Ensure data is sorted by Datetime
  mutate(PrevState = lag(State)) %>%
  filter(State == PrevState) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(error_message = paste("Consecutive values at record_id:", Id, "datetime:", Datetime, "state:", State)) %>%
  pull(error_message) -> error_messages_states

# Check if there are error messages
if (length(error_messages_states) > 0) {
  # There are errors; print the error messages
  for (error_message in error_messages_states) {
    cat("Error:", error_message, "\n")
  }
} else {
  cat("No consecutive value errors found.")
}

#Looks like it did!
```
###Summary of the rules used to adjust consecutive State values
1) If two consecutive entries for the same State are one retrospective and one current, then we only keep the current (on basis that this is more accurate than retrospective)
2) If 3 consecutive entries with same State, and visual inspection suggests differences in these entries, then the "middle" entry is an accidental entry that should be changed (see #2solution or #5solution)
3) If missing data for wearlog_on in the morning: take timestamp from out_ofbed from sleep diary
4) If participant logged a wearlog_sleep or wearlog_past_bed entry after midnight, but forgot to update the date to the "new" day, we change this manually
5) If retrospective entries conflict with previously reported current entries (see #7error), we adjust this manually according to visual inspection of raw light and activity data 
6) Retrospective entries which are not explainable by any visual inspection of the data: eliminate (see #11error)

###The wear log data is now clean from erraneous entries. However, it still contains all entries for the last day of the experiment (Monday). On this day, the participants came back to the lab and returned the light glasses. We want to keep only the first "wearlog_on" entry of this day for each participant (State = 1). For participants where this is not possible because of missing data, we use the out_ofbed entry from the wear log. 
```{r}
#Ensure the columns are formatted as the original wrlg_entries_raw dataframe
wrlg_entries_clean <- wrlg_entries %>%
  mutate(State = as.character(State),
         Datetime = as.POSIXct(Datetime, tz = tz),
         Id = as.factor(Id))

#We calculate the experimental day for each wear log entry the participant had
wrlg_entries_day <- wrlg_entries_clean %>%
  group_by(Id) %>%
  mutate(start_day = as.Date(format(as.POSIXct(first(Datetime)), "%Y-%m-%d")), #necessary to specify format for as.Date to work correctly
         current_day = as.Date(format(as.POSIXct(Datetime), "%Y-%m-%d")),
         exp_day = as.integer(difftime(current_day, start_day, units = "days")) + 1) %>%
  filter(exp_day == 8) %>% #calculate difference between start date and current date and adding 1 as a way of calculating the experimental daty, which is between 1 and 8
  ungroup()

#Create a function that returns warning or actions on the entries participants had on their last exp day
quality_check <- function(df) {
  df %>%
    group_by(Id) %>%
    arrange(Datetime) %>%
    summarise(
      result = case_when(
        n() == 1 & State[1] == "1" ~ "The first and only entry is on",
        n() > 1 & State[1] == "1" ~ "The first entry is on, but there are multiple entries",
        TRUE ~ "Check this participant"
      )
    ) %>%
    ungroup()
}

#Apply the function to the dataset 
quality_check(wrlg_entries_day)


```
#From the code above, we want to check and, when needed, fix the participants corresponding to "Check this participant" and "The first entry is on, but there are multiple entries". 
```{r}

#Participant 202. The first entry is a sleep entry, as the participant went to bed after midnight. However, the following entry is a State = 0, meaning an "off" entry, which should not be the case (State = 1 would be expected). In the participant documentation, I logged that they retrospectively logged the wearlog_on of the last day while they were at the lab already. This indicates that the participant accidentally logged wearlog_off instead of wearlog_on. This deduction also fits with the data from the sleep diary, where they indicated that they got out of bed at 7:20:00 (3 minutes before they started wearing the glasses, according to the wearlog_on entry at 7:23:00). So we manually change this. 
correct_state202_on <- "1"
wrlg_entries_clean <- wrlg_entries_clean %>%
  mutate(
    State = if_else(Id == "202" & Datetime == "2023-08-21 07:23:00" & State == 0, correct_state202_on, State))  

#Participant 204. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 205: The participant has a second entry which is an "off" entry, as well as a third on entry. We do not care about these two last entries - so we flag them by storing them in the rows_todelete df (see below) and will delete them in the original dataset.

#Participant 206: The participant as 3 entries on the last day: one on entry after midnight (State = 1), one sleep entry for when they removed them (State = 2), and one final on entry for when they started wearing them again in the morning (State = 1). We need to keep all three of them. 

#Participant 208. The first entry is a sleep entry (went to bed after midnight) and the second one, is an on entry. This makes sense and we want to keep both of them. The third entry is a State = 0 (off) entry, which should be deleted. We flag this in the rows_todelete df.

#Participant 210. The first and only entry is a sleep entry (went to bed after midnight), but there is no subsequent entry for when they started to wear the light glasses in the morning. This is missing data, and we will need to get this timestamp from the sleep diary column out_ofbed. We flag this in a new dataframe newrows_on

#Participant 212: The participant has a second entry which is an "off" entry. We do not care about this - so we flag it (see rows_todelete below) and will delete it in the original dataset.

#Participant 216: The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 218: The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 219. The first and only entry is a sleep entry on the final day of participation at 23:30. This cannot be, since participants came back to the lab in the morning. Checking the original file, we notice that wearlog_past_bed entry has the wrong date: they reported it retrospectively on the following day and accidentally inserted the date of current day, rather than the one of the previous day date. We need to change that. 
correct_date_219 <- as.POSIXct("2023-10-22 23:30:00", format = "%Y-%m-%d %H:%M:%S", tz = tz)
wrlg_entries_clean <- wrlg_entries_clean %>%
  mutate(
    Datetime = if_else(Id == "219" & Datetime == "2023-10-23 23:30:00" & State == 2, correct_date_219, Datetime))  

#However, this poses the problem that now we have no entry for participant 219 on the last day of the experiment. This is missing data, and we will need to get this timestamp from the sleep diary column out_ofbed. We flag this by storing it in a new dataframe newrows_on

#Participant 221. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 223. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 224. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 226. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them. There is also a third "off" entry which we would like to delete, and flag it in the rows_todelete df

#Participant 227. The first entry is a sleep entry (went to bed after midnight) and the second one, and last one, is an on entry. This makes sense and we want to keep both of them.

#Participant 229. The first entry is an on entry, but the participant also had 3 other entries (off entry, subsequent on entry, subsequent off entry and subsequent on entry). We want to eleiminate these ones and flag them in the rows_todelete df

#Participant 231. The first entry in an on entry, and the second one is an off entry. We want to eliminate this and flag it in the rows_todelete df

rows_todelete<- data.frame(
  Id = as.character(c(205,
                      205,
                      208,
                      212,
                      226,
                      229,
                      229,
                      229,
                      231)),
  State = as.factor(c(0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0)),
  Datetime = as.POSIXct(c("2023-09-04 07:38:00", #205
                          "2023-09-04 08:10:00", #205
                          "2023-09-11 08:03:00", #208
                          "2023-09-18 08:03:00", #212
                          "2023-11-06 06:59:00", #226
                          "2023-11-13 07:20:00", #229
                          "2023-11-13 07:55:00", #229
                          "2023-11-13 09:02:00", #229
                          "2023-11-13 09:49:00"), #231
                        format = "%Y-%m-%d %H:%M:%S",
                        tz = tz)
  )

#Deleting selected rows from original dataframe using anti_join. Anti_join returns all rows of x (wearlog_intervals_clean) without a match in y (rows_todelete)
wrlg_entries_clean <- anti_join(wrlg_entries_clean, rows_todelete) 
#wearlog_intervals_clean changes rom 790 obs to 781 obs, meaning that we have successfully delete the 9 entries we wanted. 


#As we mentioned above for participant 210 and 219, where we have missing data (i.e. no wearlog_on entry on the final experimental day), we take this timestamp from the sleep diary entry out_ofbed. Entries are also missing for participants 213, 225 and 230, and we also take this info from the sleep diary column out_ofbed.
newrows_on <- data.frame(
  Id = as.character(c(210, 213, 219, 225, 230)),
  State = as.factor(c(1, 1, 1, 1, 1)),
  Datetime = as.POSIXct(c("2023-09-11 06:16:00", #210
                        "2023-09-17 23:59:59", #213
                        "2023-10-23 07:10:00", #219
                        "2023-11-06 05:44:00", #225
                        "2023-11-13 08:15:00"), #230,
                        format = "%Y-%m-%d %H:%M:%S",
                        tz = tz))

wrlg_entries_clean <- bind_rows(wrlg_entries_clean, newrows_on) %>%
  arrange(Id, Datetime)

#wearlog_intervals_clean contains obs = 786, meaning that we successfully added the 5 entries from newrows_on (781 + 5 = 786)

```

###Quality checks after the data cleaning
After having cleaned the data, we want to make sure that a couple of things:
1) The first timestamp for all participant should be a State == 1
2) The last timestamp should also be a State == 1
```{r}
wrlg_entries_clean %>%
  group_by(Id) %>%
  summarise(
    first_state = first(State),
    last_state = last(State)
  ) %>%
  ungroup() %>%
  mutate(
    error_check = ifelse(first_state == 1 & last_state == 1, TRUE, FALSE)
  ) %>%
  {
    if (any(!.$error_check)) {
      error_ids <- .$Id[!.$error_check]
      stop(paste("Error: id(s)", paste(error_ids, collapse = ", "), "do not meet the criteria."))
    } else {
      print("No errors")
    }
  }
```

###Now we want to code the States into on, off and sleep intervals
```{r}
  
wrlg_states <- wrlg_entries_clean %>%
   mutate(
      State = case_when(
      State == 1 & (lag(State) == 0 | lag(State) == 2) ~ "on", #if on and previous one was off or sleep, it's on 
      State == 0 & (lead(State) == 2 | lag(State) == 1) ~ "off", #if off and next one is sleep, or previous one is on, it's off
      State == 2 & (lead(State) == 1) ~ "sleep", #if sleep and next one is on, then it's sleep
      .default = NA_character_)) 

#To check that the State coding into on, off and sleep worked, we want to see where NA values where assigned. We expect NA values for participant's first entry, as the previous entry is absent, and so defaulted to NA-character as specified by case_when() in the step above

first_tmp_int <- wrlg_states %>%
  group_by(Id) %>%
  filter(row_number() == first(row_number())) %>%
  ungroup()

#Our assumption was correct: all first timestamps are NA values.

#The last timestamp should be "on" for all participants
last_tmp_int <- wrlg_states %>%
  group_by(Id) %>%
  filter(row_number() == last(row_number())) %>%
  ungroup()

#For participant 225, it seems like the last timestamp is not on. Going back to the original wearlog file, we notice that there is a missing entry for the participant's "sleep" entry on Sunday (the second to last day), which leads to the first timestamp of the day after to be a "NA" value. As we have previously done, we take this value from the sleep diary, in this case from the column "sleep": 05.11.2023 22:29:00.

newrow_225 <- data.frame(
  Id = as.factor(225),
  State = as.character(2),
  Datetime = as.POSIXct("2023-11-05 22:29:00", tz = tz)
)

wrlg_entries_clean_1 <- bind_rows(wrlg_entries_clean, newrow_225) %>%
  arrange(Id, Datetime) #n of obs is now 787, meaning that we have successfully added our entry

#We now have to code again:
wrlg_states <- wrlg_entries_clean_1 %>%
   mutate(
      State = case_when(
      State == 1 & (lag(State) == 0 | lag(State) == 2) ~ "on", #if on and previous one was off or sleep, it's on 
      State == 0 & (lead(State) == 2 | lag(State) == 1) ~ "off", #if off and next one is sleep, or previous one is on, it's off
      State == 2 & (lead(State) == 1) ~ "sleep", #if sleep and next one is on, then it's sleep
      .default = NA_character_)) 

#And check that all last timestamps are now indeed on 
last_tmp_int <- wrlg_states %>%
  group_by(Id) %>%
  filter(row_number() == last(row_number())) %>%
  ungroup()

#Finally, we want to check whether we have other NA values in the dataset
na_values <- wrlg_states %>%
  filter(is.na(State)) #which results in 26 NA values, which we know are the 26 on entries. 

#We now change these 26 NA values to "On" entries
#That's correct, and we want to change that to an "on" State
wrlg_states <- wrlg_states %>%
  group_by(Id) %>%
  mutate(State = ifelse(row_number() == first(row_number()), "on", State)) %>%
  ungroup()

#We now check again is any NA values are still present
na_values <- wrlg_states %>%
  filter(is.na(State))
#which gives us a result of 0 other NA values! Great!
```

### Turning the wear log states into an interval, and merging them with the LL dataset
```{r}
#Using the sc2interval function, we can turn the Datetime column of joined_df into an interval of time
wrlg_int <- wrlg_states %>%
  group_by(Id) %>% #need to do this to prevent that Datetime from 2 different participants get merged into the same interval
  LightLogR::sc2interval(full = TRUE, length.restriction = 7 * (60*60*24)) %>%
  ungroup()

#NOTE: By setting full sc2interval(full = TRUE) we ensure that the last interval for each participant end on Sunday at 00:00, which is the last day. But there is also now a new interval for the last participation day, bringing it from the ON timestamp to midnight of that day. This will be ignored in when applying interval2state(), as the dataset.LL.all has already been filtered for the end times of day 8 to be the last wearlog on entry for that day. 
  
#Now that the joined_df is ready, we are ready to merge it to the light logger dataset
dataset.LL.wrlg <- dataset.LL.all %>% 
  LightLogR::interval2state(wrlg_int)
```


##To do: 
#up until now, we have
1) imported the LL data for all participants
2) cleaned the wearlog entries from the wear log files for each participant
3) fused the wearlog entries to the light logger enrtries

#The code that follows:
1) Incorporates the bag information into the same dataframe. However, this must be revisited: we have not changed some entries in the wearlog files, e.g. we have deleted some entries or altered them (changed an on entry to an off entry). How to adjust the bag entries based on these changes?
2) There is some code for plotting which should be moved into a separate code

### Incorporate information about the black bag use (2nd source of non-wear)
We need to re-adjust the original Wear log file, where the black bag information is contained.
```{r pressure, echo=FALSE}
#First, turn it into a dataframe
wearlog_df <- lapply(
  wearlogfiles, 
  function(x) read.csv(x, stringsAsFactors = FALSE, sep = ";")
  ) %>% 
  list_c()

#Filter the columns of interest
wearlog_bag <- wearlog_df %>%
  select("record_id", "wearlog_off", "wearlog_past_off", "wearlog_bag", "wearlog_past_bag")

#This leads to a lot of NA values in the dataframe: when wearlog_bag has value, wearlog_past_bag is NA and viceversa. We want to delete rows where these values are both NA, as they are not useful for us right now. 
wearlog_bag_clean <- wearlog_bag %>%
    rowwise()%>%
    filter(xor(!is.na(wearlog_bag), !is.na(wearlog_past_bag)))


#Combine the information from the retrospectively logged events and events logged "in real time"
wearlog_bag_clean <- wearlog_bag_clean %>%
                    mutate(timestamp_combined = case_match(wearlog_off,
                                                           NA ~ wearlog_past_off, #if wearlog_off is NA, wearlog_past_off is taken
                                                           "" ~ wearlog_past_off, #if wearlog_off is empty, wearlog_past_off is taken
                                                           .default = wearlog_off),
                           bag_combined = case_match(wearlog_bag,
                                                     NA ~ wearlog_past_bag, #if wearlog_bag is NA, wearlog_past_bag is taken
                                                     .default = wearlog_bag))%>%
                    select(record_id, timestamp_combined, bag_combined) #select columns of interest

```


### Now we have a dataframe wearlog_bag_clean that contains timestamps for when the black bag was used or not used. We'd like to join this with the dataframe that contains the Wear log entries, i.e. wearlog_int_clean
```{r pressure, echo=FALSE}

##First, we need to do some renaming 
bag_df <- wearlog_bag_clean %>%
  rename(Id = record_id, Datetime = timestamp_combined, bag = bag_combined) %>%
  mutate(Id = as.factor(Id),
         Datetime = dmy_hm(Datetime, tz = "Europe/Berlin"))
  

#Now, we want to use left_join to merge the two dataframes 
joined_df <- left_join(wrlg_int_states, bag_df, by = c("Datetime", "Id")) %>%
    mutate(bag = ifelse(is.na(bag), 2, bag)) #all the "on" and "sleep" intervals have bag = NA (since no bag was used here), so we give it a value of 2 

#Using the sc2interval function, we can turn the Datetime column of joined_df into an interval of time
joined_int <- joined_df %>%
  group_by(Id) %>% #need to do this to prevent that Datetime from 2 different participants get merged into the same interval
  LightLogR::sc2interval(full = TRUE, length.restriction = 7 * (60*60*24)) %>%
  ungroup()

#NOTE: By setting full sc2interval(full = TRUE) we ensure that the last interval for each participant end on Sunday at 00:00, which is the last day. But there is also now a new NA interval for the first participation day, up until when participants come in the lab. This will be ignored when using interval2state in the next lines
  
#Now that the joined_df is ready, we are ready to merge it to the light logger dataset
dataset.LL.joined <- dataset.LL.all %>% 
  LightLogR::interval2state(joined_int) %>%
  #note that only the State (not bag) will be carried over from the original dataset, so we re-apply the function to include the bag
  LightLogR::interval2state(joined_int, State.colname = bag)

```

### Quality checks
Because of the work-around in the code chunk above, I would like to double check that the coding of State and bag was integrated correctly
```{r}
perform_quality_checks <- function(df) {
  for (i in 1:nrow(df)) {
    if (df$State[i] == 'on' || df$State[i] == 'sleep') {
      if (df$bag[i] != 2) {
        stop(paste("Quality check failed at index", i, ": State is", df$State[i], "but bag is not 2"))
      }
    } else if (df$State[i] == 'off') {
      if (df$bag[i] != 0 && df$bag[i] != 1) {
        stop(paste("Quality check failed at index", i, ": State is off but bag is neither 0 nor 1"))
      }
    } else {
      stop(paste("Invalid State value '", df$State[i], "' at index", i, ". State should be either 'on', 'off', or 'sleep'"))
    }
  }
}

tryCatch({
  perform_quality_checks(dataset.LL.joined)
  print("Quality checks passed successfully")
}, error = function(e) {
  print(e)
})

```
####PROBLEM! Since we now changed the wearlog entries (cleaned them), this will also change the bag entry for them. How to fix this?


##Perform a sanity check that plot sleep and wake time from sleep diary 
In the plot above, we visualised time spent in each of the non-wear states: off (device not worn), on (device worn) and off for sleep (device not worn during sleep). As a sanity check, the time that the device is not worn during sleep should be similar to the time that the participants reported actually sleeping, as indicated by the sleep diary. For this reason, we follow a similar approach to the code above to visualise the amount of time participants spend asleep or awake according to the sleep diary. 
```{r}
#Locate the sleep diary files
path_sleep <- here("F:/cyepi/data/raw/group/sleepdiary")

# Get the files names from directory
sleepdiary = list.files(path_sleep, pattern="*.csv", full.names = TRUE)

#Using LightLogR, we import the files and label each timestamp as wake or sleep
sleepdiary_df <- LightLogR::import_Statechanges(sleepdiary,
                                     Datetime.format = "dmyHM",
                                     State.colnames = c("sleep", "offset"),
                                     State.encoding = c("sleep", "wake"),
                                     Id.colname = record_id,
                                     sep = ";",
                                     dec = ",",
                                     tz = tz)

#Similar to what was done for the wearlog intervals, we now turn the state changes of the sleep diary to an interval
sleep_int <- sleepdiary_df %>%
  sc2interval() %>%
  filter(!is.na(State))

#Calculate the amount of time spent in each state (either awake or alseep), for each participant across the whole experiment duration
sleep_int <- sleep_int %>%
#calculate length of each interval
  mutate(int_length = int_length(Interval) %>% as_hms()) %>% 
  #group by date and summarize 
  mutate(Date = as.Date(int_end(Interval)), #first, Date and corresponding weekday are calculated
         day = format(Date, format = "%A", locale="English") %>% 
           forcats::fct_inorder()) %>%
  group_by(Id, State, .add = TRUE) %>%
  summarize(tot_intlength = sum(int_length) %>% as_hms()) %>%
  ungroup() %>%
  filter(!is.na(State))


# Normalise it to the total time they participated in the experiment
sleep_int <- sleep_int %>%
  left_join(particip_int, by ="Id") %>% #append the column containing total participation hours from the particip_int df
  #note that particip_int has been calculate earlier and can be reused here 
  mutate(per_length = (as.numeric(tot_intlength)/as.numeric(length_par))*100) #convert to numeric as division betwen difftime objects is not supported

#Turn state into factor
as.factor(sleep_int$State)

#Organise the order of the factor levels to determine what comes first in the plot
sleep_int$State <- factor(sleep_int$State, levels = unique(sleep_int$State)[order(sleep_int$per_length, decreasing = TRUE)])

#Plot
sleep_wake_dist <-
  ggplot(data = sleep_int, aes(x=per_length, y = State, fill = State)) +
  xlim(NA,100) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    justification = -.15,
    point_color = NA,
    interval_color = NA
    ) +
  geom_boxplot(
    aes(color = State),
    width = .2,
    alpha = .2,
    outlier.shape = NA
  ) +
  geom_jitter(
    aes(colour = State),
    fill = "white",
    height = .1,
    alpha = .3
  ) +
  scale_fill_manual(
    values = c("sleep" = "darkgoldenrod2", "wake" = "darkcyan")) +
  scale_color_manual(
    values = c("sleep" = "darkgoldenrod2", "wake" = "darkcyan")) +
  scale_y_discrete(labels = c("sleep" = "Sleep", "wake" = "Wake")) +
  theme_classic() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
  labs(title = "Sleep and wake distribution across the week", x = "Percentage of time (%)") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 24),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16))

##Save plot above
ggsave(filename = "sleep_wake_dist.png",
       plot = sleep_wake_dist ,
       width = 8,
       height = 5,
       dpi = 600,
       path= "F:/cyepi/code/outputs")
```





