---
title: 'RQ1: button press and wearlog'
author: "Carolina Guidolin"
date: "2024-03-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# This document is the continuation of nonwear_source_fusion. Here, we will be testing the concordance between two sources of non-wear: the button press and the wear log entries.
Note that the following code chunks build on variables and dfs generated by the nonwear_source_fusion.Rmd file and should thus be run after them.

##First, out of interest, we check when participants accidentally pressed the button twice consecutively

```{r}

#First, we filter the dataframe for rows that were a button press was performed (EVENT = 1)
data.bp <- dataset.LL.clean %>%
  filter(EVENT == "1")

#Checking how often a double button press occurred, i.e. 
double_bp <- data.bp %>%
  group_by(Id) %>%
  mutate(td = difftime(lead(Datetime), Datetime, units = "secs"),
         consec_bp = td == 10 | lag(td) == 10) %>% #keeps rows were td between current and next row is 10, or current and previous is 10
  filter(consec_bp == TRUE) %>%
  ungroup() #in the entire dataset, a consecutive button press was only recorded 11 times 

#Now we want to clean the dataset from these consecutive button press events, as we know that they actually corresponded to only one event (on, off or sleep)
data.bp.clean <- data.bp %>%
  group_by(Id) %>%
  mutate(td = difftime(lead(Datetime), Datetime, units = "secs"),
         keep_event = is.na(td) | td != 10) %>%
  filter(keep_event == TRUE) %>%
  select(-td, -keep_event) %>%
  ungroup() #total of 680 - 11 observations = 669 observations

#To avoid having the Datetime column twice with the same name, we change the Datetime of the joined_df to "timestamp". This represents the Wear log entry timestamp
wearlog_tmp <- joined_df %>%
  rename(timestamp = "Datetime")

#Find the nearest wearlog entry for eah button press (event = 1)
bp_wearlog_df <- data.bp.clean %>%
  group_by(Id) %>%
  left_join(wearlog_tmp, join_by(closest( Datetime >= timestamp))) %>% #biggest timestamp that is less than Datetime, i.e. the closest timestamp
  select(Id.x, Datetime, EVENT, State.x, timestamp)

```


## Including Plots

You can also embed plots, for example:

```{r}

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
