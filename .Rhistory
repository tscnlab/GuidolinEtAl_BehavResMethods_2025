breaks = c(0.01, 0.05, 0.1),
labels = c(0.01, 0.05, 0.1),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Log-transformed and normalised \nPIM threshold based detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0.1,0,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
# Apply min max normalisation to the raw data
## Function that will normalise - (same as above!)
min_max_normalisation <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
## Normalise activity within each Id
normalised_raw_pim_df <- df.LL.nosleep %>%
group_by(Id) %>% # we want to normalise within each Id
mutate(norm_pim = min_max_normalisation(PIM)) %>%
ungroup()
## Let's visualise the distribution of the normalised raw PIM
ggplot(normalised_raw_pim_df) +
geom_histogram(aes(x=norm_pim))
#Create a sequence of PIM thresholds at 0.001 unit steps (because PIM values only range from 0 to 1, and they are heavily skewed towards 0)
norm_pimthresholds <- c(0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.01)
#Empty list to store classification results
prc_list <- list()
#Running a for loop to generate a prc for all selected PIM thresholds
for (threshold in norm_pimthresholds) {
prc_result <- generate_prc(
dataset = normalised_raw_pim_df,
low_var = "norm_pim",
min_length = 72, #12 minutes (n of observations)
max_interrupt = 0, #0 minute (n of observations)
threshold = threshold
)
# Add the current threshold as a column in prc_result
prc_result <- prc_result %>%
mutate(threshold = threshold) # Add threshold column
prc_list[[as.character(threshold)]] <- prc_result
}
#Turn into a df
norm_raw_prcurve_pim <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
norm_raw_prcurve_pim$threshold <- as.numeric(norm_raw_prcurve_pim$threshold)
# Adding f1 value
norm_raw_prcurve_pim_f1 <- norm_raw_prcurve_pim %>%
mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))
# Plot this PR curve
prc_pim_raw_norm <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = norm_raw_prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "Normalised PIM threshold",
low = "blue", high = "lightblue",
limits= c(0.001, 0.01),
breaks = c(0.001, 0.005, 0.01),
labels = c(0.001, 0.005, 0.01),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Raw and normalised \nPIM threshold based detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0.1,0,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
rolled.pim <- df.LL.nosleep %>%
group_by(Id) %>%
mutate(rolled_median_PIM = zoo::rollapplyr(PIM, width = 60, FUN = median, fill = NA, align = "center")) %>%
ungroup()
# To get an idea of the distribution of the data, let's calculate some descriptive stats
rolled_pim_summary <- rolled.pim %>%
group_by(Id) %>%
summarise(mean_pim = mean(rolled_median_PIM, na.rm = TRUE),
sd_pim = sd(rolled_median_PIM, na.rm = TRUE),
median_pim = median(rolled_median_PIM, na.rm = TRUE),
min_pim = min(rolled_median_PIM, na.rm = TRUE),
max_pim = max(rolled_median_PIM, na.rm = TRUE)) %>%
ungroup()
# Visualise distribution
ggplot(rolled.pim) +
geom_histogram(aes(x=rolled_median_PIM)) ##very similar to the original distribution of PIM
#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)
#Empty list to store classification results
prc_list <- list()
#Running a for loop to generate a prc for all selected PIM thresholds
for (threshold in pimthresholds) {
prc_result <- generate_prc(
dataset = rolled.pim,
low_var = "rolled_median_PIM",
min_length = 72, #12 minutes (n of observations)
max_interrupt = 0, #0 minute (n of observations)
threshold = threshold
)
# Add the current threshold as a column in prc_result
prc_result <- prc_result %>%
mutate(threshold = threshold) # Add threshold column
prc_list[[as.character(threshold)]] <- prc_result
}
#Turn into a df
rolled_raw_prcurve_pim <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
rolled_raw_prcurve_pim$threshold <- as.numeric(rolled_raw_prcurve_pim$threshold)
# Adding f1 value
rolled_raw_prcurve_pim_f1 <- rolled_raw_prcurve_pim %>%
mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))
# Plot this PR curve
prc_pim_rolled_raw <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = rolled_raw_prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "PIM threshold",
low = "blue", high = "lightblue",
limits= c(5, 50),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Smoothed PIM threshold \nbased detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0.1,0,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
# First, we have to apply a rolling median to the log transformed data
rolled.log.pim <- log.df.LL.nosleep %>%
group_by(Id) %>%
mutate(rolled_median_PIM = zoo::rollapplyr(log.PIM, width = 60, FUN = median, fill = NA, align = "center")) %>%
ungroup()
View(rolled_raw_prcurve_pim_f1)
#Create a sequence of PIM thresholds at 5 unit steps
log_pimthresholds <- log10(c(5,10, 15, 20, 25, 30, 35, 40, 45, 50))
#Empty list to store classification results
prc_list <- list()
#Running a for loop to generate a prc for all selected PIM thresholds
for (threshold in log_pimthresholds) {
prc_result <- generate_prc(
dataset = rolled.log.pim,
low_var = "rolled_median_PIM",
min_length = 72, #12 minutes (n of observations)
max_interrupt = 0, #0 minute (n of observations)
threshold = threshold
)
# Add the current threshold as a column in prc_result
prc_result <- prc_result %>%
mutate(threshold = threshold) # Add threshold column
prc_list[[as.character(threshold)]] <- prc_result
}
#Turn into a df
rolled_log_prcurve_pim <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
rolled_log_prcurve_pim$threshold <- as.numeric(rolled_log_prcurve_pim$threshold)
# Adding f1 value
rolled_log_prcurve_pim_f1 <- rolled_log_prcurve_pim %>%
mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))
# Plot this PR curve
prc_pim_rolled_log <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = rolled_log_prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "Log PIM threshold",
low = "blue", high = "lightblue",
limits= c(log10(5), log10(50)),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Log-transformed and smoothed \nPIM threshold based detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0.1,0,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
# We already have a log transformed and smoothed dataset from the code chunk above, i.e. rolled.log.pim
# This means that we jump to step 3 and apply a normalisation to the rolled.log.pim df
## We need to change the normalisation function so that it handles NA values resulting from the smoothing
na_min_max_normalisation <- function(x) {
# Apply the normalisation only if the value is not NA
if (all(is.na(x))) {
return(rep(NA_real_, length(x)))  # If values are NA, return a vector of NAs
} else {
# Normalise only the non-NA values and handle each element
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
}
# Apply the normalisation
norm_rolled_log_pim <- rolled.log.pim %>%
group_by(Id) %>% # we want to normalise within each Id
mutate(n_r_l_pim = na_min_max_normalisation(rolled_median_PIM)) %>%
ungroup()
# Apply the algorithm
#Create a sequence of PIM thresholds at 0.001 unit steps (because PIM values only range from 0 to 1, and thy are heavily skewed towards 0)
norm_pimthresholds <- c(0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.01)
#Empty list to store classification results
prc_list <- list()
#Running a for loop to generate a prc for all selected PIM thresholds
for (threshold in norm_pimthresholds) {
prc_result <- generate_prc(
dataset = norm_rolled_log_pim,
low_var = "n_r_l_pim",
min_length = 72, #12 minutes (n of observations)
max_interrupt = 0, #0 minute (n of observations)
threshold = threshold
)
# Add the current threshold as a column in prc_result
prc_result <- prc_result %>%
mutate(threshold = threshold) # Add threshold column
prc_list[[as.character(threshold)]] <- prc_result
}
#Turn into a df
norm_rolled_log_prcurve_pim <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
norm_rolled_log_prcurve_pim$threshold <- as.numeric(norm_rolled_log_prcurve_pim$threshold)
# Adding f1 value
norm_rolled_log_prcurve_pim_f1 <- norm_rolled_log_prcurve_pim %>%
mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))
# Plotting this final PR curve
prc_pim_norm_rolled_log <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = norm_rolled_log_prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "Normalised PIM threshold",
low = "blue", high = "lightblue",
limits= c(0.001, 0.01),
breaks = c(0.001, 0.005, 0.01),
labels = c(0.001, 0.005, 0.01),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Log-transformed, smoothed and \nnormalised PIM threshold based detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0.1,0,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
# Combining in one single plot
preprocess_multiplot <- cowplot::plot_grid(prc_pim_thresholds,
prc_pim_raw_norm,
prc_pim_rolled_raw,
prc_pim_log,
prc_pim_log_norm,
prc_pim_rolled_log,
prc_pim_norm_rolled_log,
labels = c("A", "B", "C", "D", "E", "F", "G"),
ncol = 3,
align = "hv")
# Saving the plot
ggsave(filename = "pim_pre-process_1.png",
plot = preprocess_multiplot,
width = 14,
height = 14,
dpi = 600,
bg = "white",
path = here::here("outputs", "supplementary"))
# Combining in one single plot
preprocess_multiplot <- cowplot::plot_grid(prc_pim_thresholds,
prc_pim_raw_norm,
prc_pim_rolled_raw,
prc_pim_log,
prc_pim_log_norm,
prc_pim_rolled_log,
prc_pim_norm_rolled_log,
labels = c("A", "B", "C", "D", "E", "F", "G"),
ncol = 3,
align = "hv")
# PIM
prc_pim_thresholds <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "PIM threshold",
low = "blue", high = "lightblue",
limits= c(5,50),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Raw PIM threshold \nbased detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0,0.5,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
# Combining in one single plot
preprocess_multiplot <- cowplot::plot_grid(prc_pim_thresholds,
prc_pim_raw_norm,
prc_pim_rolled_raw,
prc_pim_log,
prc_pim_log_norm,
prc_pim_rolled_log,
prc_pim_norm_rolled_log,
labels = c("A", "B", "C", "D", "E", "F", "G"),
ncol = 3,
align = "hv")
# Saving the plot
ggsave(filename = "pim_pre-process_1.png",
plot = preprocess_multiplot,
width = 14,
height = 14,
dpi = 600,
bg = "white",
path = here::here("outputs", "supplementary"))
View(prc_pim_thresholds)
View(prc_pim_thresholds)
# PIM
prc_pim_thresholds <- ggplot() +
xlim(0,1) +
ylim(0,1) +
geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
scale_colour_gradient(
name = "PIM threshold",
low = "blue", high = "lightblue",
limits= c(5,50),
guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
labs(x="True positive rate (recall)",
y = "Positive predictive value \n(precision)",
title = "Raw PIM threshold \nbased detection") +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, size = 20),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.key.size = unit(8, "mm"),
legend.position = "bottom",
legend.box = "horizontal",
plot.margin = unit(c(0,0.5,0,0), unit ="cm")) +
coord_fixed(ratio = 1)
View(prcurve_pim)
View(prcurve_pim_f1)
View(norm_raw_prcurve_pim)
View(norm_raw_prcurve_pim_f1)
View(rolled_raw_prcurve_pim_f1)
View(log_prcurve_pim_f1)
View(norm_log_prcurve_pim_f1)
View(rolled_log_prcurve_pim_f1)
View(norm_rolled_log_prcurve_pim_f1)
# Function to visualise algorithm performance
base::source(here::here("03_analysis", "functions", "alg_perf_fun.R"))
#Empty list to store classification results
prc_list <- list()
classified_prc_medi <- alg_perf(
dataset = df.LL.nosleep,
low_var = "MEDI",
min_length = 126, #21 minutes (n of observations)
max_interrupt = 0, #0 minutes (n of observations)
threshold = 1 #1 mEDI lux
)
medi_sc <- classified_prc_medi %>%
group_by(Id) %>%
mutate(interval_group = consecutive_id(classification)) %>% #need to set default for first value
group_by(Id, interval_group) %>%
summarise(classification = first(classification), #keep only first value for each Id and interval_group
xmin = first(Datetime),
xmax = last(Datetime)) %>%
ungroup()
View(wearlog_entries_raw)
knitr::opts_chunk$set(echo = TRUE)
wearlog_past <- wearlogfiles %>%
#import_Statechanges from LightLogR to create states based on timestamps
LightLogR::import_Statechanges(
sep = ";", dec = ",", Datetime.format = "dmyHM", tz = "Europe/Berlin",
Id.colname = record_id,
State.colnames =
c("wearlog_on",
"wearlog_off",
"wearlog_past_on",
"wearlog_past_off",
"wearlog_bed",
"wearlog_past_sleep"),
State.encoding =
c("on",
"off",
"past_on",
"past_off",
"sleep",
"past_sleep")
)
View(wearlog_past)
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise()
View(wearlog_past_summary)
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(count())
View(wearlog_past_summary)
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(count(n))
wearlog_past_summary <- wearlog_past %>%
summarise(count(State))
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(count(State))
wearlog_past_summary <- wearlog_past %>%
as.factor(State) %>%
summarise(count())
View(wearlog_past_summary)
wearlog_past_summary <- wearlog_past %>%
as.factor(State) %>%
summarise(count(State))
wearlog_past$State <- as.factor(wearlog_past$State)
wearlog_past_summary <- wearlog_past %>%
summarise(count(State))
wearlog_past$State <- as.factor(wearlog_past$State)
wearlog_past_summary <- wearlog_past %>%
summarise(count())
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(n=n())
View(wearlog_past_summary)
wearlog_past <- wearlogfiles %>%
#import_Statechanges from LightLogR to create states based on timestamps
LightLogR::import_Statechanges(
sep = ";", dec = ",", Datetime.format = "dmyHM", tz = "Europe/Berlin",
Id.colname = record_id,
State.colnames =
c("wearlog_on",
"wearlog_off",
"wearlog_past_on",
"wearlog_past_off",
"wearlog_bed",
"wearlog_past_sleep"),
State.encoding =
c("present",
"present",
"past_",
"past",
"present",
"past")
)
wearlog_past$State <- as.factor(wearlog_past$State)
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(n=n())
View(wearlog_past_summary)
wearlog_past <- wearlogfiles %>%
#import_Statechanges from LightLogR to create states based on timestamps
LightLogR::import_Statechanges(
sep = ";", dec = ",", Datetime.format = "dmyHM", tz = "Europe/Berlin",
Id.colname = record_id,
State.colnames =
c("wearlog_on",
"wearlog_off",
"wearlog_past_on",
"wearlog_past_off",
"wearlog_bed",
"wearlog_past_sleep"),
State.encoding =
c("present",
"present",
"past",
"past",
"present",
"past")
)
wearlog_past$State <- as.factor(wearlog_past$State)
wearlog_past_summary <- wearlog_past %>%
group_by(State) %>%
summarise(n=n())
View(wearlog_past_summary)
View(wrlg_int)
