---
title: "plots_wrlg"
author: "Carolina Guidolin"
date: "2024-05-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Wear log plots

This script creates:
1) Plots to visualise how much time participants spent in each Wear log state across the week
2) Descriptive statistics on how much time participants spent in each Wear log state across the week 


###1) Plots to visualise how much time participants spend in each wear log state across the week.
We would like to visualise this as a distribution of time spent in each State, where the max x axis is 7 days (168 hours). Since 168hours is not very indicative for someone looking at the graph, we also want to express this as a percentage of time, where 168 hours is 100%

```{r}
#First, while all participants took part in the experiment for 7 days, they started at different times, and so it is important not just to approximate to 7 days (168 hours), but to calculate the specific 100% of "participation time" for each participant. For this, we first need to calculate the n of hours that each participant spends in the experiment.

Sys.setlocale("LC_TIME", "en_US.UTF-8") #needed to run this code to have the days displayed in English and not German

exp_duration <- filtered_time %>%
  mutate(id_int = lubridate::interval(start, end),
         id_duration = lubridate::int_length(id_int) %>% as_hms()) %>% #tot hours of participation for each participant
  select(Id, id_duration)

#Loading in a package to create raincloud plots
library(ggdist)

#Time in each interval can be calculated from wrlg_int 
int_duration <- wrlg_int %>%
  group_by(Id) %>%
  #filter out the last "on" interval, since it goes to midnight of the final exp day, which is not actual data
  filter(row_number() != n()) %>% #this filters out the rows where row n is equal to tot number of rows, i.e. last enrty
  ungroup() %>%
  #calculate length of each individual interval
  mutate(int_length = int_length(Interval) %>% as_hms()) %>% 
  #group by Id and State to then  summarise the total (i.e. across the whole week) duration of each state (on/off/sleep) 
  group_by(Id, State, .add = TRUE) %>%
  summarize(tot_intlength = sum(int_length) %>% as_hms()) %>%
  ungroup() %>%
  #The first states for each Id (midnight of previous day to study start) are NA, we want to filter them out since they are not active participation
  filter(!is.na(State))

# Normalise it to the total time participants spent in the experiment, expressed in percentage
int_duration <- int_duration %>%
  left_join(exp_duration, by ="Id") %>% #append the column containing total participation hours from the exp_duration df
  mutate(id_duration_n= as.numeric(tot_intlength)/as.numeric(id_duration), #convert to numeric as division betwen difftime objects is not supported, n stands for "normalised"
         id_duration_per = id_duration_n*100) #calculate percentage of time

as.factor(int_duration$State)

#Plot
int_duration$State <- factor(int_duration$State, levels = c("sleep", "off", "on"))

states_dist_jitter2 <- ggplot(data = int_duration, aes(x=id_duration_per, y = State, fill = State)) +
  scale_x_continuous(limits = c(0,100), expand = c(0.05,0.05)) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    justification = -.25,
    point_color = NA,
    interval_color = NA
    ) +
  geom_boxplot(
    aes(color = State),
    width = .3,
    alpha = .2,
    outlier.shape = NA
  ) +
  geom_jitter(
    aes(colour = State),
    fill = "white",
    height = .1,
    alpha = .3,
    size = 1.2
  ) +
  scale_fill_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_color_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_y_discrete(labels = c("on" = "Wake 'on'", "off" = "Wake 'off'", "sleep" = "Sleep 'off'")) +
  theme_ggdist() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
 # ggpubr::rremove("xlab")+ 
  labs(title = "(Non-)wear time distribution across the week", x = "Percentage of time (%)") +
  coord_fixed(ratio = 12) + # reduce white space between categorical variables on y axis
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 20),
        axis.text.x = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_text(size = 14))

#We want to add a 2nd axis to the plot, where hours, instead of % of time, are specified

int_duration$tot_intlength_hours <- as.numeric(int_duration$tot_intlength) / 3600
  
second_x_axis <- ggplot(data = int_duration, aes(x = tot_intlength_hours, y = 0.01)) +
  geom_blank() +  # Create an empty plot
  scale_x_continuous(limits = c(0, 166), breaks = c(0, 20, 40, 60, 80, 100, 120, 140, 166), 
                     expand = c(0.05,0.05)) +
  coord_fixed(ratio = 4) +
  theme_ggdist() +
  labs(x = "Time (hours)")  +
  theme(axis.title = element_text(size = 16),
        axis.text = element_text(size = 14)) +
  ggpubr::rremove("y.axis") +
  ggpubr::rremove("ylab") + 
  ggpubr::rremove("y.ticks") +
  ggpubr::rremove("y.text") 
  

# Combine the plots
library(patchwork)

state_dist_2axis_2 <- states_dist_jitter2/second_x_axis

```

###Save plots above
```{r}
ggsave(filename = "state_dist_jitter2.png",
       plot = states_dist_jitter2 ,
       width =8,
       height = 5,
       dpi = 600,
       path= "G:/cyepi/code/outputs")

ggsave(filename = "state_dist_2axis_3.svg",
       plot = state_dist_2axis_2,
       width = 7,
       height = 4,
       dpi = 600,
       path= "G:/cyepi/code/outputs")
```

###2) Calculate descriptive statistics on how much time participants spent in each Wear log state across the week 
```{r}
#Calculating median time in each state

wrlg_state_summary <- int_duration %>%
  group_by(State) %>%
  summarise(mean = mean(id_duration_per),
            sd = sd(id_duration_per),
            min = min(id_duration_per),
            max = max(id_duration_per),
            median = median(id_duration_per),
            range = max-min) %>%
  ungroup()

```



###The following chunks of code contain alternative plots to those above
```{r}
#Extra plot 1: Same plot as states_dist_jitter, but without jitter and boxplot, just with distribution
  states_dist_histo <- ggplot(data = int_duration, aes(x=id_duration_per, y = State, fill = State)) +
  xlim(NA,100) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    point_color = NA,
    interval_color = NA
 #   .width = .7
    ) +
  ggdist::stat_dotsinterval(
    side = "bottom",
    scale = .3,
    slab_colour = NA,
    slab_linewidth = NA) +
  scale_fill_manual(
    values = c("off" = "#16439C", "on" = "palegreen4", "sleep" = "darkgoldenrod2")) +
  scale_y_discrete(labels = c("on" = "On", "off" = "Off", "sleep" = "Off while\nsleeping")) +
  theme_classic() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
  labs(title = "(Non-)wear time distribution across the week", x = "Percentage of time (%)") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 24),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16))


```
```{r}
#Extra plot 3: only visualise non-wear time distribution 

tot_nonwear <- int_duration%>%
  filter(State == "off")

#tot_nonwear$offtime_per <- (tot_nonwear$off_time / (24*7))*100

nonwear_dist_overview <- ggplot(data = int_duration, aes(x = id_duration_per, fill = State))  +
  xlim(NA, 100) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    ) +
  ggdist::stat_dotsinterval(
    side = "bottom",
    scale = .3,
    slab_colour = NA,
    slab_linewidth = NA) +
   scale_fill_manual(values = c("off" = "#16439C")) +
  theme_classic() +
  labs(title = "Non-wear time distribution", x = "Non-wear time (%)") +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
  ggpubr::rremove("y.text") +
  theme(plot.title = element_text(hjust = 0.5, size = 24),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.x.top = element_blank(),
        axis.ticks.x.top = element_blank(),
        axis.line.x.top = element_blank(),
        legend.position = "none") +
  scale_x_break(c(15,99.9),
                ticklabels = 100)

```


We now want to visualise when, during the day, participants took the light logger on and/or off
```{r}
timing_off <- wrlg_int %>%
  filter(State == "off") %>%
  mutate(start = int_start(Interval),
         end = int_end(Interval),
         centre_point = as.POSIXct(start + difftime(end,start)/2, tz = tz),
         centre_point_h = hour(centre_point))

timing_dens_plot_svg <- ggplot(timing_off, aes(x = as.numeric(centre_point_h), y = after_stat(count))) +
  geom_histogram(color = "black", fill = "darkred", alpha = 0.6, position = "identity", bins = 24) +
  geom_density(color = "black", fill= "darkred", alpha = 0.3, outline.type = "upper") +
  labs(x = "Centre point of non-wear interval", y = "Number of Wake 'off' events", title = "Timing of non-wear episodes across the day") +
  scale_x_continuous(
    breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24),
    labels = c("00:00", "02:00", "04:00", "06:00", "08:00", "10:00", "12:00", "14:00", "16:00", "18:00", "20:00", "22:00", "24:00"),
    expand = c(0.0,0.0)) +
   theme_ggdist() +
   theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 22),
        axis.text.x = element_text(size = 16, angle = 45, hjust = 1),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16))

ggsave(filename = "timing_dens_plot.svg",
       plot = timing_dens_plot_svg,
       width = 7,
       height = 4,
       dpi = 600,
       path= "G:/cyepi/code/outputs")

```

##Looking at weekday vs weekend difference
```{r}
int_wknd_wkday <- wrlg_int %>%
  group_by(Id) %>%
  #filter out the last "on" interval, since it goes to midnight of the final exp day, which is not actual data
  filter(State == "off") %>%
  ungroup() %>%
  #calculate length of each individual interval
  mutate(int_length = int_length(Interval) %>% as_hms(),
         int_start = int_start(Interval),
         int_end = int_end(Interval),
         day.start = int_start %>% format(format = "%a"), #format as day
         day.end = int_end %>% format(format = "%a"), #format as day
         int_start = int_start %>% hms::as_hms(), #transform xmin to time (currently Datetime)
         int_end = int_end %>% hms::as_hms(), #transform xmax to time (currently Datetime)
         day.start = factor(day.start, levels = unique(day.start)),
         day.end = factor(day.end, levels = unique(day.end)))

#Step 1: collect the part of the data that does not cross day boundaries
off_times1 <-
  int_wknd_wkday %>%
  filter(day.start == day.end)

#Step 2: Collect part of the data that does cross bounderies and split it by day, i.e. at midnight. 
off_times2 <-
int_wknd_wkday %>% filter(day.start != day.end) %>%
  rowwise() %>%
  mutate(
    new_entry = list(
      tibble(
        int_start=c(int_start, hms::as_hms("00:00:00")),
        int_end =c(hms::as_hms("23:59:59"), int_end),
        day.start.1=c(day.start, day.end),
        day.end.1=c(day.start, day.end)
      )
    )
  ) %>%
  select(Id, State, Interval, new_entry) %>%
  unnest(new_entry)

wknd_wkday.combined <- 
  bind_rows(off_times1 %>% rename(day.start.1 = day.start),
          off_times2) %>%
  select(-c(day.end.1, day.end, int_length)) %>%
  rename(Day.data = day.start.1) %>%
  mutate(off_length = as_hms(int_end - int_start),
         day_type = ifelse(Day.data %in% c("Sat", "Sun"), "weekend", "weekday")) %>%
  #group by Id and State to then  summarise the total (i.e. across the whole week) duration of each state (on/off/sleep) 
  group_by(Id, day_type) %>%
  summarize(off_length = sum(off_length) %>% as_hms()) %>%
  ungroup() %>%
  complete(Id, day_type, fill = list(off_length = as_hms(0)))

wknd_wkday <- wknd_wkday.combined %>%
  left_join(exp_duration, by ="Id") %>% #append the column containing total participation hours from the exp_duration df
  mutate(wknd_duration = hms::as_hms(48 * 3600),
         wk_duration = hms::as_hms(id_duration - wknd_duration),
         normalised_length = if_else(day_type == "weekend", as.numeric(off_length)/as.numeric(wknd_duration), 
                                     as.numeric(off_length)/as.numeric(wk_duration)),
         perc_length = normalised_length * 100)

 wknd_wk_dist.svg <- ggplot(data = wknd_wkday, aes(x=perc_length, y = day_type, fill = day_type)) +
  scale_x_continuous(limits = c(0,100), expand = c(0.05,0.05)) +
  ggdist::stat_halfeye(
    aes(colour = day_type,
        fill = day_type),
    adjust = .5,
    justification = -.45,
    point_color = NA,
    interval_color = NA,
    scale = 0.5,
    height = 1
    ) +
  geom_boxplot(
    aes(color = day_type),
    width = 0.25,
    alpha = .2,
    outlier.shape = NA
  ) +
  geom_jitter(
    aes(colour = day_type),
    fill = "white",
    height = .1,
    alpha = .3,
    size = 1.2
  ) +
  scale_fill_manual(
    values = c("weekday" = "#bf0000", "weekend" = "#800000")) +
  scale_color_manual(
    values = c("weekday" = "#bf0000", "weekend" = "#800000")) +
  scale_y_discrete(labels = c("weekday" = "Weekday", "weekend" = "Weekend day")) +
  theme_ggdist() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
 # ggpubr::rremove("xlab")+ 
  labs(title = "Non-wear time distribution across weekdays and weekend days", x = "Percentage of time (%)") +
  coord_fixed(ratio = 16) + # reduce white space between categorical variables on y axis
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 20),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 16),
        axis.text.y = element_text(size = 16))
 
 ggsave(filename = " wknd_wk_dist.svg",
       plot =  wknd_wk_dist.svg,
       width = 7,
       height = 4,
       dpi = 600,
       path= "G:/cyepi/code/outputs")

```






```{r}
#Extra plot2: visualing only non-wear time for each day of the week

#Non-wear time can be calculated from the joined_int dataset
nonwear_time <-wrlg_int %>%
#filter for intervals on non-wear (State == "off")
  filter(State == "off") %>% 
  #calculate the non-wear time through the interval column
  mutate(off_time = int_length(Interval) %>% as_hms()) %>% 
  #group by date and summarize daily non-wear time
  mutate(Date = as.Date(int_end(Interval)), #first, Date and corresponding weekday are calculated
         day = format(Date, format = "%A", locale="English") %>% 
           forcats::fct_inorder()) %>%
  group_by(Id, day, .add = TRUE) %>%
  summarize(off_time = sum(off_time)) %>%
  ungroup()

#There are participants who have 0 non-wear time for a day, i.e. they have no State == off, who we still want to display as 0 points in our plot. Since we filtered for State == off above, we need to use complete to fill in days of 0 non-wear with 0 values. 
off_states <- off_states %>%
  complete(Id, day, fill = list(off_time = as_hms(0)))

off_states$off_time <- as.numeric(off_states$off_time, "hours")

#plotting the data
nonwear_duration <- off_states %>% 
ggplot(aes(x = day, y = off_time)) +
  geom_violin(alpha = 0.3, aes(fill=day), trim = TRUE) + 
  geom_dotplot(binaxis = "y",
               stackdir = "center",
               dotsize = 0.5,
               binwidth = 0.1) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 30, face = "plain"),
        axis.text = element_text(size=18),
        axis.title = element_text(size=18),
        axis.title.y = element_text(size = 20),
        axis.title.x = element_text(size = 20),
        legend.position = "none") +
  xlab("Experimental day") + 
  ylab("Non-wear time (hours)") +
  scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16), 
                     label = c(0, 2, 4, 6, 8, 10, 12, 14, 16), 
                     expand = c(0,0)) +
  ggtitle("Self-reported non-wear time entries (Wear log)")
```


