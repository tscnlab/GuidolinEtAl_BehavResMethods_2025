---
title: 'RQ1: button press and wearlog'
author: "Carolina Guidolin"
date: "2024-03-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# This document is the continuation of nonwear_source_fusion. Here, we will be testing the concordance between two sources of non-wear: the button press and the wear log entries.
Note that the following code chunks build on variables and dfs generated by the nonwear_source_fusion.Rmd file and should thus be run after them.

##First, out of interest, we check when participants accidentally pressed the button twice consecutively

```{r}

#First, we filter the dataframe for rows that were a button press was performed (EVENT = 1)
data.bp <- dataset.LL.clean %>%
  filter(EVENT == "1")

#If a button press occurred within the same minute, we want to eliminate it as likely the participants pressed it multiple times by accident
data.bp.clean <- data.bp %>%
  group_by(Id) %>%
  filter(abs(difftime(lead(Datetime), Datetime, units = "secs")) >= 60) %>%
  ungroup()

#To avoid having the Datetime column twice with the same name (from LL and wearlog dataframes), we change the Datetime of the joined_df to "timestamp". This represents the Wear log entry timestamp
wearlog_tmp <- joined_df %>%
  rename(timestamp = "Datetime")

#Use data.tables package to perform a rolling join and match the Datetime of one dataset to the nearest Datetime of the other dataset
data.table::setDT(data.bp.clean)[, join_date := Datetime] #convert to data.table and append original column
data.table::setDT(wearlog_tmp)[, join_date := timestamp] #convert to data.table and append original column

bp_wearlog_df <- data.bp.clean[wearlog_tmp, on = .(Id, join_date), roll = "nearest"] %>%
  #Perform a left join of the two datasets, for each row of wearlog_tmp the nearest data.bp.clean timestamp is found
  .[, tmp_diff := abs(join_date - Datetime) / 60] %>%  
  #Calculate difference in minutes between the two datetime columns
  .[, tmp_comparison := tmp_diff <= 2] %>%
  #Check if difference is less than or equal to 2 minutes and store it as TRUE or FALSE
  .[, .(Id, Datetime, tmp_wearlog = join_date, tmp_diff, tmp_comparison)] #select cols of interest


```



```{r}

joined_df <- joined_df %>%
  rename(tmp_wearlog = "Datetime")

tr2 <- bp_wearlog_df %>%
  left_join(joined_df, join_by(tmp_wearlog, Id))

```


## Including Plots

You can also embed plots, for example:

```{r}

#Understand how many TRUE and FALSE
event_counts <- table(bp_wearlog_df$tmp_comparison)
event_counts_df <- as.data.frame(event_counts)
names(event_counts_df) <- c("Event", "Count")

#Plot
ggplot(event_counts_df, aes(x = Event, y = Count, fill = Event)) +
  geom_bar(stat = "identity") +
  labs(x = "Event", y = "Count", fill = "Event") +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "red")) +
  theme_minimal()

#Old code
tmp_comp <- wearlog_tmp[data.bp.clean, on = .(Id, join_date), roll = "nearest"] %>%
  select(Id, timestamp, join_date) %>%
  rename(tmp_wearlog = "timestamp", tmp_bp = "join_date")

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
all.equal(bp_wearlog_df,tmp_comp)

#Find the nearest wearlog entry for each button press (event = 1)
bp_wearlog_df <- data.bp.clean %>%
  group_by(Id) %>%
  left_join(wearlog_tmp, join_by(closest( Datetime >= timestamp))) %>% #biggest timestamp that is less than Datetime, i.e. the closest timestamp
  select(Id.x, Datetime, EVENT, State.x, timestamp)

```

