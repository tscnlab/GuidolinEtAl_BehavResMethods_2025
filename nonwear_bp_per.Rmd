---
title: 'RQ1: button press and wearlog'
author: "Carolina Guidolin"
date: "2024-03-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# This document is the continuation of nonwear_source_fusion. Here, we will be testing the concordance between two sources of non-wear: the button press and the wear log entries.
Note that the following code chunks build on variables and dfs generated by the nonwear_source_fusion.Rmd file and should thus be run after it.

##Cleaning the dataset and matching the dataset of the button press events and that of the wear log events
```{r}
#First, we filter the dataframe for rows that were a button press was performed (EVENT = 1)
data.bp <- dataset.LL.clean %>%
  filter(EVENT == "1")

#If a button press occurred within the same minute, we want to eliminate it as likely the participants pressed it multiple times by accident
data.bp.clean <- data.bp %>%
  group_by(Id) %>%
  filter(abs(difftime(lead(Datetime), Datetime, units = "secs")) >= 60) %>%
  ungroup()

#Use data.tables package to perform a rolling join and match the Datetime of one dataset to the nearest Datetime of the other dataset
data.table::setDT(data.bp.clean)[, join_date := Datetime] #convert to data.table and append original column
data.table::setDT(joined_df)[, join_date := Datetime] #convert to data.table and append original column

bp_wearlog_df <- data.bp.clean[joined_df, on = .(Id, join_date), roll = "nearest"] %>%
  #Perform a left join of the two datasets, for each row of joined_df (wear log entries) the nearest data.bp.clean timestamp (button press) is found
  .[, tmp_diff := abs(join_date - Datetime) / 60] %>%  
  #Calculate difference in minutes between the two datetime columns
  .[, tmp_comparison := tmp_diff <= 2] %>%
  #Check if difference is less than or equal to 2 minutes and store it as TRUE or FALSE
  .[, .(Id, Datetime, State, tmp_wearlog = join_date, tmp_diff, tmp_comparison)] #select cols of interest

#FALSE means that a wearlog event does not have bp within 2 minutes
#TRUE means that a wearlog event ha a bp within 2 minutes
```

##Another way to think about it: classify non-wear intervals based on Wear log in intervals that also have a button press event or that do not have one
```{r}
library(data.table)

window_checker <- function(window = 120){
  int_dec <- joined_int %>%
  group_by(Id) %>%
  filter(State == "off") %>%
  mutate(start = int_start(Interval),
         end = int_end(Interval))

#window <- 120# 2 minutes in seconds

# Function to check if an event falls within the specified window at both extremities of the interval
event_within_window <- function(event_time, interval_start, interval_end) {
  within_window <- event_time >= interval_start - window & event_time <= interval_end + window
  return(within_window)
}

# For each participant, check if there is an EVENT = 1 within the time window of the interval start
integrated_data_start <- int_dec %>%
  left_join(data.bp.clean, by = "Id") %>%
  mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
  group_by(Id, start) %>%
  summarise(has_event_start = any(event_within_start))

integrated_data_end <- int_dec %>%
  left_join(data.bp.clean, by = "Id") %>%
  mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
  group_by(Id, end) %>%
  summarise(has_event_end = any(event_within_end))

merged_data <- int_dec %>%
  left_join(integrated_data_end, by = c("Id","end")) %>%
  left_join(integrated_data_start, by = c("Id", "start"))

merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
  classify_interval(x[1], x[2])
})
merged_data
}

window_var <- c(60, 120, 180, 240, 300, 360, 420, 480, 540, 600) %>%
  map(window_checker, .progress = TRUE)  

tibble_win <- window_var%>% 
  map(\(x) x %>% ungroup() %>%
  count(classification))

window_sizes <- c(60, 120, 180, 240, 300, 360, 420, 480, 540, 600)
event_counts <- data.table::rbindlist(lapply(window_sizes, tibble_win))


#Result: a data frame that returns TRUE and FALSE if a button press event was within 2 minutes of the start and of the end of the non-wear interval
```

```{r}

window_checker <- function(window = 120){
  int_dec <- joined_int %>%
    group_by(Id) %>%
    filter(State == "off") %>%
    mutate(start = int_start(Interval),
           end = int_end(Interval))
  
  # Function to check if an event falls within the specified window at both extremities of the interval
  event_within_window <- function(event_time, interval_start, interval_end) {
    within_window <- event_time >= interval_start - window & event_time <= interval_end + window
    return(within_window)
  }
  
  # For each participant, check if there is an EVENT = 1 within the time window of the interval start
  integrated_data_start <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
    group_by(Id, start) %>%
    summarise(has_event_start = any(event_within_start))
  
  integrated_data_end <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
    group_by(Id, end) %>%
    summarise(has_event_end = any(event_within_end))
  
  merged_data <- int_dec %>%
    left_join(integrated_data_end, by = c("Id","end")) %>%
    left_join(integrated_data_start, by = c("Id", "start"))
  
  merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
    classify_interval(x[1], x[2])
  })
  
  tibble_win <- merged_data %>%
    ungroup() %>%
    count(classification) %>%
    mutate(window_size = window)
  
  return(tibble_win)
}

window_var <- c(60, 120, 180, 240, 300, 360, 420, 480) %>%
  map(window_checker, .progress = TRUE)  

event_counts <- data.table::rbindlist(window_var)

event_per <- event_counts %>%
  mutate(n_per = (n/197)*100)

event_per_agg <- event_per %>%
  group_by(window_size) %>%
  summarise(n_per_closed = first(n_per[classification == "Closed interval"]),
            n_per_open = first(n_per[classification == "Open ended both"])) %>%
  ungroup()

library(ggforce)
library(ggrepel)

val <- c("1" = "forestgreen", "2" = "darkmagenta", "3" = "tomato1", "4" = "tomato2", "5" = "tomato3", "6" = "royalblue1", "7" = "royalblue2", "8" = "royalblue3")

int_type_per <- ggplot(event_per_agg, aes(x = n_per_closed, y =n_per_open, colour = as.factor(window_size/60))) +
  geom_point(position = position_dodge(w=0.3),
             alpha =0.3, size=4) +
  xlim(0, 100) +
  ylim(0, 100) +
  labs(title = "Non-wear interval type according to button press events", x = "Closed intervals (%)", y = "Open intervals (%)", color = "Window size\n(minutes)") +
  facet_zoom(ylim = c(8,14),
             xlim = c(86.5,91)) +
  scale_color_manual(values = val,
                     breaks = c("1", "2", "3", "4", "5", "6", "7", "8")) +
  annotate("text", size = 4, x = 86.8, y = 13.35, label = "1") +
  annotate("text", size = 4, x = 88.83, y = 11.31, label = "2") +
  annotate("text", size = 4, x = 89.72, y = 10.30, label = "3") +
  annotate("text", size = 4, x = 89.84, y = 10.30, label = "4") +
  annotate("text", size = 4, x = 89.96, y = 10.30, label = "5") +
  annotate("text", size = 4, x = 90.24, y = 9.79, label = "6") +
  annotate("text", size = 4, x = 90.36, y = 9.79, label = "7") +
  annotate("text", size = 4, x = 90.48, y = 9.79, label = "8") +
  theme_bw()  +
  theme(plot.title = element_text(hjust = 0.5, size = 24),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))

  
```


```{r}
ggsave(filename = "int_bp.png",
       plot = int_type_per,
       width = 10,
       height = 8,
       dpi = 600,
       path= "F:/cyepi/code/outputs")
```


##Based on approach above, we can classify intervals in:
1. Open ended: no button press at either ends of the interval
2. Closed: button press at both ends of the interval 
3. Open ended right: button press only at the left (start) but not right (end) of the interval
4. Open ended left: button press only at the right (end) but not left (start) of the interval
```{r}
classify_interval <- function(has_event_start, has_event_end) {
  if (has_event_start && has_event_end) {
    return("Closed interval")
  } else if (!has_event_start && has_event_end) {
    return("Open ended left")
  } else if (has_event_start && !has_event_end) {
    return("Open ended right")
  } else {
    return("Open ended both")
  }
}

##Filter out the first button press event (Datetime) and check whether that creates a one sided open interval interval
```




```{r}

```
















```{r}
# Function to check if an event falls within a time window from the beginning and the end of an interval
compute_event_counts <- function(window_size) {
  event_within_window <- function(event_time, interval_start, interval_end) {
    within_window <- event_time >= interval_start - window_size & event_time <= interval_end + window_size
    return(within_window)
  }
  
  # For each participant, check if there is an event within the time window of the interval start
  integrated_data_start <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
    group_by(Id, start) %>%
    summarise(has_event_start = any(event_within_start))
  
  integrated_data_end <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
    group_by(Id, end) %>%
    summarise(has_event_end = any(event_within_end))
  
  merged_data <- int_dec %>%
    left_join(integrated_data_end, by = c("Id","end")) %>%
    left_join(integrated_data_start, by = c("Id", "start"))
  
  # Apply classification function to each row
  merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
    classify_interval(x[1], x[2])
  })
  
  # Return the table of event counts
  return(table(merged_data$classification))
}

# Define window sizes
window_sizes <- c(120, 180, 300, 600)  # 2 minutes, 3 minutes, 5 minutes, 10 minutes

# Compute event counts for each window size
event_counts <- data.table::rbindlist(lapply(window_sizes, compute_event_counts))



# Plot
barplot(cbind(close_intervals_counts, open_ended_intervals_counts), beside = TRUE, 
        legend.text = window_sizes, 
        main = "Event Classification Counts for Different Time Windows",
        xlab = "Event Classification", ylab = "Count",
        col = rainbow(length(window_sizes)),
        names.arg = c("Closed", "Open Left", "Open Right", "Open Both"))
```

```{r}


```




```


## Including Plots

You can also embed plots, for example:

```{r}
joined_df <- joined_df %>%
  rename(tmp_wearlog = "Datetime")

tr2 <- bp_wearlog_df %>%
  left_join(joined_df, join_by(tmp_wearlog, Id))
#Understand how many TRUE and FALSE
event_counts <- table(bp_wearlog_df$tmp_comparison)
event_counts_df <- as.data.frame(event_counts)
names(event_counts_df) <- c("Event", "Count")

#Plot
ggplot(event_counts_df, aes(x = Event, y = Count, fill = Event)) +
  geom_bar(stat = "identity") +
  labs(x = "Event", y = "Count", fill = "Event") +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "red")) +
  theme_minimal()

#Old code
tmp_comp <- wearlog_tmp[data.bp.clean, on = .(Id, join_date), roll = "nearest"] %>%
  select(Id, timestamp, join_date) %>%
  rename(tmp_wearlog = "timestamp", tmp_bp = "join_date")

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
all.equal(bp_wearlog_df,tmp_comp)

#Find the nearest wearlog entry for each button press (event = 1)
bp_wearlog_df <- data.bp.clean %>%
  group_by(Id) %>%
  left_join(wearlog_tmp, join_by(closest( Datetime >= timestamp))) %>% #biggest timestamp that is less than Datetime, i.e. the closest timestamp
  select(Id.x, Datetime, EVENT, State.x, timestamp)

```

