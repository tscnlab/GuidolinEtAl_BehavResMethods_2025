---
title: 'RQ1: button press and wearlog'
author: "Carolina Guidolin"
date: "2024-03-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# This document is the continuation of nonwear_source_fusion. Here, we will be testing the concordance between two sources of non-wear: the button press and the wear log entries.
Note that the following code chunks build on variables and dfs generated by the nonwear_source_fusion_wrlg.Rmd file and should thus be run after it.

##Cleaning the dataset and matching the dataset of the button press events and that of the wear log events
```{r}
#First, we filter the dataframe for rows that were a button press was performed (EVENT = 1)
data.bp <- dataset.LL.wrlg %>%
  filter(EVENT == "1")

#If a button press occurred within the same minute (60s), we want to eliminate it as likely the participants pressed it multiple times by accident
data.bp.clean <- data.bp %>%
  group_by(Id) %>%
  filter(abs(difftime(lead(Datetime, default = first(Datetime)), Datetime, units = "secs")) >= 60) %>% #default = first(Datetime) is set for instances where no next Datetime exists. E.g. for the last timestamp of each group (Id)
  ungroup()

#For the "off" intervals calculated in joined_int, calculate timestamp corresponding to the start of the interval
wrlg_int_start <- wrlg_int %>%
  filter(!is.na(State)) %>% #the first Interval is NA for all participants (see LightLogR sc2interval function)
  filter(State == "off") %>%
  mutate(start = lubridate::int_start(Interval))

#For the "off" intervals calculated in joined_int, calculate timestamp corresponding to the end of the interval
wrlg_int_end <- wrlg_int %>%
  filter(!is.na(State)) %>% #the first Interval is NA for all participants (see LightLogR sc2interval function)
  filter(State == "off") %>% 
  mutate(end = lubridate::int_end(Interval))

```  

##Creating a function which classifies the wear log detected "off" intervals based on the presence of a button press at both ends of the interval. 
1. Unbounded: button press missing ither at both ends or only at one end
2. Bounded: button press at both ends of the interval 
```{r}
classify_interval <- function(has_start, has_end) {
  if (has_start && has_end) {
    return("bounded")
  } else if (!has_start && has_end) {
    return("unbounded")
  } else if (has_start && !has_end) {
    return("unbounded")
  } else {
    return("unbounded")
  }
}

#Function to check if an event falls within the specified window at both extremities of the interval
  event_within_window <- function(event_time, interval_start, interval_end) {
    within_window <- (event_time >= interval_start - window) | (event_time <= interval_end + window)
    return(within_window)
  }
```


#Use data.tables package to perform a rolling join and match the Datetime of one dataset to the nearest Datetime of the other dataset. Data tables are normal data frames, but they have extra features which allow to work better with them. 

```{r}
data.table::setDT(data.bp.clean)[, join_date := Datetime] #convert to data.table and append original column that we want to keep
data.table::setDT(wrlg_int_start)[, join_date := start] #convert to data.table and append original column that we want to keep
data.table::setDT(wrlg_int_end)[, join_date := end] #convert to data.table and append original column that we want to keep

window_sizes <- c(1, 2, 3, 4, 5, 6, 7, 8)

interval_checker <- lapply(window_sizes, function(window) {
  
  #Find the nearest button press for the start of each "off" wear log interval, based on the specified time window
  bp_wearlog_start <- data.bp.clean[wrlg_int_start, on = .(Id, join_date), roll = "nearest"] %>%
  #Perform a left join of the two datasets, for each row of wrlg_int (wear log entries) the nearest data.bp.clean timestamp (button press) is found
  .[, tmp_diff := as.numeric(difftime(Datetime, join_date, units = "mins"))] %>%  
  #Calculate difference in minutes between the two datetime columns
  .[, has_start := tmp_diff <= window] %>%
  #Check if difference is less than or equal to window minutes and store it as TRUE or FALSE
  .[, .(Id, Datetime, i.State, tmp_wearlog_start = join_date, tmp_diff, has_start)] %>% #select cols of interest
  rename(tmp_bp_start = Datetime)
  
  #Find the nearest button press for the end of each "off" wear log interval - based on the specified time window
  bp_wearlog_end <- data.bp.clean[wrlg_int_end, on = .(Id, join_date), roll = "nearest"] %>%
  #Perform a left join of the two datasets, for each row of wrl_int (wear log entries) the nearest data.bp.clean timestamp (button press) is found
  .[, tmp_diff := as.numeric(difftime(Datetime, join_date, units = "mins"))] %>%  
  #Calculate difference in minutes between the two datetime columns
  .[, has_end := tmp_diff <= window] %>%
  #Check if difference is less than or equal to window minutes and store it as TRUE or FALSE
  .[, .(Id, Datetime, i.State, tmp_wearlog_end = join_date, tmp_diff, has_end)] %>% #select cols of interest
  rename(tmp_bp_end = Datetime,
         i.Id = Id) 

  #Result: has_start is TRUE for "off" wear log intervals where a button press is present within time window of interest, at the start of the interval;  has_end  is TRUE for "off" wear log intervals where a button press is present within time window of interest, at the end of the interval.
  
  #Based on this, we can classify intervals based on the presence of a button press using the function classify_interval
  
  #First, we combine the two data tables (start and end)
  bp_wrlg_df <- bp_wearlog_start %>%
  cbind(bp_wearlog_end) %>%
  select(Id, tmp_bp_start, tmp_bp_end, tmp_wearlog_start, tmp_wearlog_end, has_start, has_end)
  
  #Add a column called classification that returns one of the two types of interval: 1) bounded, 2) unbounded
  
  bp_wrlg_df$classification <- apply(bp_wrlg_df[, c("has_start", "has_end")], 1, function(x) {
    classify_interval(x[1], x[2])
  })
  
  bp_wrlg_df$window_size <- window #add a column which contains the information of the window size utilised
  
  return(bp_wrlg_df)
  
})

#Now the results are stored in interval_checker, which is a list. We'd like to store this into a dataframe and calculate the number of interval types for each window size
bd_wrlg_df <- bind_rows(interval_checker) %>%
  group_by(window_size) %>% 
  count(classification) %>%
  mutate(n_per = (n/199)*100) #calculate percentage of each interval type based on total number of interval, which we know is 199


```

#Visualise the data - do on Monday
```{r}
#Turn data in wide format for plotting
bp_wrlg_df_wide <- bd_wrlg_df %>%
  pivot_wider(names_from = classification, values_from = c(n, n_per))

#Create colour palette
val <- c("1" = "forestgreen", "2" = "darkmagenta", "3" = "tomato1", "4" = "tomato2", "5" = "tomato3", "6" = "royalblue1", "7" = "royalblue2", "8" = "royalblue3")

#Plot
wrlg_int_classified <- ggplot(bp_wrlg_df_wide, aes(x = n_per_bounded, y = n_per_unbounded, colour = as.factor(window_size))) +
  geom_point(position = position_dodge(w=0.3),
             alpha =0.3, size=4) +
  xlim(0, 100) +
  ylim(0, 100) +
    scale_color_manual(values = val,
                     breaks = c("1", "2", "3", "4", "5", "6", "7", "8")) +
  labs(title = "Non-wear interval type according to \nbutton press events", x = "Closed intervals (%)", y = "Open intervals (%)", color = "Window size\n(minutes)") +
  theme_bw()  +
  geom_rect(aes(xmin = 60.0, xmax = Inf, ymin = -Inf, ymax = 40.0), fill = "gold1", colour = "gold1", alpha = 0.03) +
  theme(plot.title = element_text(hjust = 0.5, size = 24),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14)) +
  coord_fixed(ratio = 1)

#Zoom in the yellow shaded area
wrlg_int_classified_zoom <- ggplot(bp_wrlg_df_wide, aes(x = n_per_bounded, y = n_per_unbounded, colour = as.factor(window_size))) +
  geom_point(position = position_dodge(w=0.3),
             alpha =0.3, size=4) +
  xlim(60.0, 100) +
  ylim(0, 40.0) +
    scale_color_manual(values = val,
                     breaks = c("1", "2", "3", "4", "5", "6", "7", "8")) +
  labs(title = "Non-wear interval type according to \nbutton press events", x = "Closed intervals (%)", y = "Open intervals (%)", color = "Window size\n(minutes)") +
  theme_bw()  +
  theme(plot.title = element_text(hjust = 0.5, size = 24),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14)) +
  coord_fixed(ratio = 1)

```

```{r}
ggsave(filename = "wrlg_int_classified.png",
       plot = wrlg_int_classified,
       width = 10,
       height = 8,
       dpi = 600,
       path= "G:/cyepi/code/outputs")

ggsave(filename = "wrlg_int_classified_zoom.png",
       plot = wrlg_int_classified_zoom,
       width = 10,
       height = 8,
       dpi = 600,
       path= "G:/cyepi/code/outputs")
```





##Old code
```{r}
window <- 120

window_checker <- function(window = 120){
  int_dec <- joined_int %>%
    group_by(Id) %>%
  #  filter(State == "off") %>%
    mutate(start = int_start(Interval),
           end = int_end(Interval))

  # For each participant, check if there is an EVENT = 1 within the time window of the interval start
  integrated_data_start <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
    group_by(Id, start) %>%
    summarise(has_event_start = any(event_within_start))
  
  integrated_data_end <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
    group_by(Id, end) %>%
    summarise(has_event_end = any(event_within_end))
  
  merged_data <- int_dec %>%
    left_join(integrated_data_end, by = c("Id","end")) %>%
    left_join(integrated_data_start, by = c("Id", "start"))
  
  merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
    classify_interval(x[1], x[2])
  })
  
  tibble_win <- merged_data %>%
    ungroup() %>%
    count(classification) %>%
    mutate(window_size = window)
  
  return(tibble_win)
}

window_var <- c(60, 120, 180, 240, 300, 360, 420, 480) %>%
  map(window_checker, .progress = TRUE)  

event_counts <- data.table::rbindlist(window_var)

event_per <- event_counts %>%
  mutate(n_per = (n/197)*100)

event_per_agg <- event_per %>%
  group_by(window_size) %>%
  summarise(n_per_closed = first(n_per[classification == "Closed interval"]),
            n_per_open = first(n_per[classification == "Open ended both"])) %>%
  ungroup()

library(ggforce)
library(ggrepel)

val <- c("1" = "forestgreen", "2" = "darkmagenta", "3" = "tomato1", "4" = "tomato2", "5" = "tomato3", "6" = "royalblue1", "7" = "royalblue2", "8" = "royalblue3")

int_type_per <- ggplot(event_per_agg, aes(x = n_per_closed, y =n_per_open, colour = as.factor(window_size/60))) +
  geom_point(position = position_dodge(w=0.3),
             alpha =0.3, size=4) +
  xlim(0, 100) +
  ylim(0, 100) +
  labs(title = "Non-wear interval type according to button press events", x = "Closed intervals (%)", y = "Open intervals (%)", color = "Window size\n(minutes)") +
  facet_zoom(ylim = c(8,14),
             xlim = c(86.5,91)) +
  scale_color_manual(values = val,
                     breaks = c("1", "2", "3", "4", "5", "6", "7", "8")) +
  annotate("text", size = 4, x = 86.8, y = 13.35, label = "1") +
  annotate("text", size = 4, x = 88.83, y = 11.31, label = "2") +
  annotate("text", size = 4, x = 89.72, y = 10.30, label = "3") +
  annotate("text", size = 4, x = 89.84, y = 10.30, label = "4") +
  annotate("text", size = 4, x = 89.96, y = 10.30, label = "5") +
  annotate("text", size = 4, x = 90.24, y = 9.79, label = "6") +
  annotate("text", size = 4, x = 90.36, y = 9.79, label = "7") +
  annotate("text", size = 4, x = 90.48, y = 9.79, label = "8") +
  theme_bw()  +
  theme(plot.title = element_text(hjust = 0.5, size = 24),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14))

  
```


##Old code
```{r}

library(data.table)

window_checker <- function(window = 120){
  int_dec <- joined_int %>%
  group_by(Id) %>%
  filter(State == "off") %>%
  mutate(start = int_start(Interval),
         end = int_end(Interval))

#window <- 120# 2 minutes in seconds

# Function to check if an event falls within the specified window at both extremities of the interval
event_within_window <- function(event_time, interval_start, interval_end) {
  within_window <- event_time >= interval_start - window & event_time <= interval_end + window
  return(within_window)
}

# For each participant, check if there is an EVENT = 1 within the time window of the interval start
integrated_data_start <- int_dec %>%
  left_join(data.bp.clean, by = "Id") %>%
  mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
  group_by(Id, start) %>%
  summarise(has_event_start = any(event_within_start))

integrated_data_end <- int_dec %>%
  left_join(data.bp.clean, by = "Id") %>%
  mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
  group_by(Id, end) %>%
  summarise(has_event_end = any(event_within_end))

merged_data <- int_dec %>%
  left_join(integrated_data_end, by = c("Id","end")) %>%
  left_join(integrated_data_start, by = c("Id", "start"))

merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
  classify_interval(x[1], x[2])
})
merged_data
}

window_var <- c(60, 120, 180, 240, 300, 360, 420, 480, 540, 600) %>%
  map(window_checker, .progress = TRUE)  

tibble_win <- window_var%>% 
  map(\(x) x %>% ungroup() %>%
  count(classification))

window_sizes <- c(60, 120, 180, 240, 300, 360, 420, 480, 540, 600)
event_counts <- data.table::rbindlist(lapply(window_sizes, tibble_win))
```
















```{r}
# Function to check if an event falls within a time window from the beginning and the end of an interval
compute_event_counts <- function(window_size) {
  event_within_window <- function(event_time, interval_start, interval_end) {
    within_window <- event_time >= interval_start - window_size & event_time <= interval_end + window_size
    return(within_window)
  }
  
  # For each participant, check if there is an event within the time window of the interval start
  integrated_data_start <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_start = event_within_window(Datetime, start, end)) %>%
    group_by(Id, start) %>%
    summarise(has_event_start = any(event_within_start))
  
  integrated_data_end <- int_dec %>%
    left_join(data.bp.clean, by = "Id") %>%
    mutate(event_within_end = event_within_window(Datetime, start, end)) %>%
    group_by(Id, end) %>%
    summarise(has_event_end = any(event_within_end))
  
  merged_data <- int_dec %>%
    left_join(integrated_data_end, by = c("Id","end")) %>%
    left_join(integrated_data_start, by = c("Id", "start"))
  
  # Apply classification function to each row
  merged_data$classification <- apply(merged_data[, c("has_event_start", "has_event_end")], 1, function(x) {
    classify_interval(x[1], x[2])
  })
  
  # Return the table of event counts
  return(table(merged_data$classification))
}

# Define window sizes
window_sizes <- c(120, 180, 300, 600)  # 2 minutes, 3 minutes, 5 minutes, 10 minutes

# Compute event counts for each window size
event_counts <- data.table::rbindlist(lapply(window_sizes, compute_event_counts))



# Plot
barplot(cbind(close_intervals_counts, open_ended_intervals_counts), beside = TRUE, 
        legend.text = window_sizes, 
        main = "Event Classification Counts for Different Time Windows",
        xlab = "Event Classification", ylab = "Count",
        col = rainbow(length(window_sizes)),
        names.arg = c("Closed", "Open Left", "Open Right", "Open Both"))
```

```{r}


```




```


## Including Plots

You can also embed plots, for example:

```{r}
joined_df <- joined_df %>%
  rename(tmp_wearlog = "Datetime")

tr2 <- bp_wearlog_df %>%
  left_join(joined_df, join_by(tmp_wearlog, Id))
#Understand how many TRUE and FALSE
event_counts <- table(bp_wearlog_df$tmp_comparison)
event_counts_df <- as.data.frame(event_counts)
names(event_counts_df) <- c("Event", "Count")

#Plot
ggplot(event_counts_df, aes(x = Event, y = Count, fill = Event)) +
  geom_bar(stat = "identity") +
  labs(x = "Event", y = "Count", fill = "Event") +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "red")) +
  theme_minimal()

#Old code
tmp_comp <- wearlog_tmp[data.bp.clean, on = .(Id, join_date), roll = "nearest"] %>%
  select(Id, timestamp, join_date) %>%
  rename(tmp_wearlog = "timestamp", tmp_bp = "join_date")

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
all.equal(bp_wearlog_df,tmp_comp)

#Find the nearest wearlog entry for each button press (event = 1)
bp_wearlog_df <- data.bp.clean %>%
  group_by(Id) %>%
  left_join(wearlog_tmp, join_by(closest( Datetime >= timestamp))) %>% #biggest timestamp that is less than Datetime, i.e. the closest timestamp
  select(Id.x, Datetime, EVENT, State.x, timestamp)

```

