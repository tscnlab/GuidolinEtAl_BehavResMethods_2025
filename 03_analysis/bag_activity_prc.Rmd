---
title: "bag_activity_prc"
author: "Carolina Guidolin"
date: "2024-07-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Note
This script should be run after files in 01_import and 02_datapreparation have been run. 

# Aim
To know whether we can precisely predict non-wear times (detected by the wear log) using information from the black back use (low mEDI) and/or activity (low PIM). To do this, we build a precision recall curve (PRC).

## Testing steffen's function which indentifies clusters of non-wear time 
These functions (find_clusters_funs, loaded in separately) identify clusters of low illuminance. The following parameters can be selected: 
1) logical values where clusters should be found - in this case, low illuminance or low activity values (below a certain threshold)
2) minimum length of the clusters
3) max interrpution length for the cluster to still be identified as such 

### Loading in the data, if not already there
```{r}
clean.LL.wrlg <- readRDS('clean_data.Rds')
```


#Identifying clusters of low activity (PIM)
```{r}
#In order to build a PRC, we need to test the performance of our algorithm by changing the input parameters. Here, we modifiy the threshold for "low activity", i.e. the PIM value. 

#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)

#Empty list to store classification results
prc_pim_list <- list()
  
  for (threshold in pimthresholds) {

  pim_clusters <- dataset.LL.wrlg %>%
    ungroup() %>%
   filter(!State == "sleep") %>%
   # Replace `low_activity` by the (logical) variable for which the clusters 
   # should be found.
   mutate(low_pim = PIM < threshold) %>% 
   # Nest by groups, e.g., participant, period. Replace with grouping variables 
   # in your data, such that the function is applied separately per consecutive 
   # timeseries (e.g., from one subject during one period).
    nest_by(Id) %>% 
   mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_pim, 
        min_length = "10 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_pim_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


  pimclusters_clean <- pim_clusters %>%
   select(Id, Datetime, State, bag, is_low_pim_cluster) %>%
    mutate(
      State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_pim_cluster = case_when(
      is_low_pim_cluster == TRUE ~ 0,
      is_low_pim_cluster == FALSE ~ 1
    )) 

#We want to build a precision recall curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

  pimclusters_clean <- pimclusters_clean %>%
   mutate(classification = case_when(
      State == 0 & is_low_pim_cluster == 0 ~ "TP",
      State == 0 & is_low_pim_cluster == 1 ~ "FN",
      State == 1 & is_low_pim_cluster == 0 ~ "FP",
      State == 1 & is_low_pim_cluster == 1 ~ "TN",
     .default = NA_character_))

  prc_pim <- pimclusters_clean %>%
    group_by(classification) %>% ##!!If you want to visualise info per participatn, you also have to group_by Id. Else, only by classification
   summarise(count = n())  %>%
   pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
    mutate(TPR = TP/(TP+FN), #this is the formula for TPR (true positive rate)
           FPR = FP/(FP+TN), #this is the formula for the FPR (false positive rate)
           PPV = TP/(TP+FP), #positive predictive value
          NPV = TN/(FN+TN), #negative predictive values
           threshold = threshold)  #adding manually which threshold I am considering here 

  #Add the result to the list
   prc_pim_list[[as.character(threshold)]] <- prc_pim
  }

#Turn the list with the results into a df 
prcurve_pim <- bind_rows(prc_pim_list)

#Turn thresholds from character to factor for plotting
prcurve_pim$threshold <- as.numeric(prcurve_pim$threshold)

```



```{r}
prcurve_pim_f1 <- prcurve_pim %>%
  mutate(f1_score = ((1+b^2) * PPV * TPR)/((b^2 * PPV) + TPR))

#Again, precision is low (PPV), indicating that there are instances where our classifier labels non-wear but actually the participant was wearing it. 

# Recall also saturates, meaning that the proportion of non-wear that our classifier can detect does not change with different activity levels. Meaning no matter the activity that participant has, our model does not change performance based on.

#If we increase our range of thresholds of PIM (5 to 500), the recall gets better with increasing activity threshold. Meaning that there are probably instances when the participants are walking around with it in a bag. 
```


# Identifying clusters of low light levels (mEDI)
```{r}
#Similarly to above, we create a series of thresholds that will be fed into the function and be used to build the prc 
medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_medi_list <- list()
threshold = 2
for (threshold in medithresholds) {

medi_clusters <- dataset.LL.204 %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = "10 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


mediclusters_clean <- medi_clusters %>%
  select(Id, Datetime, State, MEDI, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    )) 

#We want to build a precision recall curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

mediclusters_clean <- mediclusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

prc_medi <- mediclusters_clean %>%
  group_by(classification) %>% #!! if you want to visualise individual PRC, then you have to group_by(Id, classification). Else, only group_by(classification)
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
  mutate(TPR = TP/(TP+FN), #true positive rate
         FPR = FP/(FP+TN), #false positive rate
         PPV = TP/(TP+FP), #positive predictive value
         NPV = TN/(FN+TN), #negative predictive value
         threshold = threshold)  #adding manually which threshold I am considering here 

 #Add the result to the list
  prc_medi_list[[as.character(threshold)]] <- prc_medi
}

#Turn the list with the results into a df 
prcurve_medi <- bind_rows(prc_medi_list)

#Turn thresholds from character to factor for plotting
prcurve_medi$threshold <- as.numeric(prcurve_medi$threshold)
```

#Calculate F1 score to understand the agreement between my precision and recall
```{r}
b = 1 #set beta as 1

prcurve_medi_f1 <- prcurve_medi %>%
  mutate(f1_score = ((1+b^2) * PPV * TPR)/((b^2 * PPV) + TPR))

##With increasing medi levels, the recall (TPR) remains virtually identical, suggesting that the proportion of all non-wear identified correctly does not change (proportion of true non-wear compared to all non-wear) -> meaning that we are capturing all the non-wear that our classifier can capture, and changing on threshold in not changing 

#However, the precision (PPV) - proportion of non-wear labels was actually non-wear, gets worse, meaning we get more false positives because we are being more liberal in what we label as non-wear state.

#
```


# Visualisation of the precision recall curves for activity and light (all participants together)
```{r}

prc_combined <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5))  +
  ggnewscale::new_scale_color() + #need this to reset the color scale for the next plot
  #Adding the arrow to show directionality (for illuminance)
  geom_segment(aes(x = 0.6,
                   y = 0.54,
                   xend = 0.63,
                   yend = 0.27),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  #Adding the arrow to show directionality (for activity)
  geom_segment(aes(x = 0.49,
                   y = 0.165,
                   xend = 0.57,
                 yend = 0.115),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity \nand illuminance thresholds",
       subtitle = "Min. length = 2 min, max. interruption = 1 min") +
  #Adding the symbols for the arrows as text and the label
  annotate("text",
           x = 0.64,
           y = 0.45,
           label = sprintf('\u2191')) + #arrow pointing upwards for Illuminance
  geom_text(aes(x= 0.80,
                y = 0.445,
                label = "Illuminance")) + #label of illuminance
  annotate("text",
           x = 0.28,
           y = 0.14,
           label = sprintf('\u2191')) + #arrow pointing upwards for activity
  geom_text(aes(x = 0.39,
                y = 0.135,
                label = "Activity")) + #label for activity
  geom_text(aes(x=0.215,
                y = 0.535,
                label = "Baseline classifier"),
            color = "darkgrey",
            size = 3.8) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, colour = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "prc_thresholds_2min_1.png",
       plot = prc_combined,
       height = 5.5, 
       width = 5,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw")
```

##Visualisation of activity and light prc for each participant in a multiplot
This is helpful to know whether the prc performs differently in each participant. We also want to know: if our algorithm performs poorly, is it because the participants were not compliant with using the black bag? So, the first step is actually to calculate how often the bag was actually used when logging and off event. 

###Calculating % usage of black bag 
```{r}
 bag_use <- dataset.LL.wrlg %>%
  group_by(Id) %>%
   mutate(bag_use = case_when(
     State == "off" & bag == 0 ~ "notused", #when State is 0ff and bag is 0, it was not used
     State == "off" & bag == 1 ~ "used", #when state is off and bag is 1, it was used
     .default = NA_character_)) %>%
  ungroup()

per_bag_use <- bag_use %>%
  group_by(Id, bag_use) %>% 
  summarise(count = n()) %>% #calculating how many used and notused per participant
  filter(!is.na(bag_use)) %>% #eliminate NAs which correspond to when State is on or sleep
  complete(bag_use = c("used", "notused"), fill = list(count = 0)) %>% #if participant does not have values for "used" or "notused" because they wither never used the bag, or always used it, we replace that with 0
  mutate(total = sum(count), #counting total entries per participant
         compliance_per = if_else(bag_use == "used", (count*100)/total, NA), #calculating % of "used" over total entries
         compliance_per = round(compliance_per, 1)) %>% #rounding the percentage value to 1 decimal point
  filter(!is.na(compliance_per)) #eliminate the NA that comes from the ifelse


```

###Plotting the PRC for each participant and labelling % compliance of bag use 
For this, you need to modify the prc code above (for both PIM and MEDI) to group_by (Id, classification). See line 251.
```{r}
prc_multiplot <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     low = "blue", high = "lightblue",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5)) +
  facet_wrap(~ Id) +
  coord_fixed(ratio = 1) +
  ggnewscale::new_scale_color() +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  facet_wrap(~Id) +
  geom_text(data = per_bag_use, aes(x = 0.5, y = 0.95, label = paste("Bag use:",compliance_per,"%")), size = 4.2) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity \nand illuminance thresholds") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

#Save the plot
ggsave(filename = "10min-prc-multiplot-raw-labelled.png",
       plot = prc_multiplot,
       height = 11, 
       width = 11,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc")

```

## Varying the other 2 input parameters of the cluster detection function 

## Step 1: vary mEDI thresholds
```{r}

medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_m_list <- list()

for (threshold in medithresholds) {
  
  prc_m_list[[threshold]] <- generate_prc_medi(
    dataset = dataset.LL.wrlg,
    low_medi_var = "MEDI",
    min_length = "10 mins",
    max_interrupt = "1 mins",
    medi_threshold = threshold
  )
}

prc_medi_1 <- bind_rows(prc_m_list, .id = "threshold")
#Turn threshold to factor for plotting
prc_medi_1$threshold <- as.numeric(prc_medi_1$threshold)

#Let's plot to see what the result looks like

prc_medi_thresholds <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_medi_1, aes(x = TPR, y = PPV, colour = threshold)) +
  scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on illuminance thresholds",
       subtitle = "Min. length = 10 min, max. interrupt = 1 min") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, color = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_medi_thresholds.png",
       plot = prc_medi_thresholds,
       height = 5.5, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw")

```

## Step 2: vary length of interval 
```{r}
#We create min_length ranging from 2 to 11
min_lengths <- paste0(seq(2, 11, by = 1), " min")
#From the previous plot, we know that lower mEDI thresholds are better so we keep it to 2
medi_threshold = 2
#We keep the max_interrupt at 1 minute
max_interrupt = "1 min"


#Empty list to store classification results
prc_m_list <- list()

for (min_length in min_lengths) {
  
  prc_m_list[[min_length]] <- generate_prc_medi(
    dataset = dataset.LL.wrlg,
    low_medi_var = "MEDI",
    min_length = min_length,
    max_interrupt = max_interrupt,
    medi_threshold = medi_threshold
  )
}

prc_medi_2 <- bind_rows(prc_m_list, .id = "min_length")
#Turning min_length into a factor for plotting
prc_medi_2$min_length <- gsub(" min", "", prc_medi_2$min_length) #first, eliminate the "min"
prc_medi_2$min_length <- as.factor(prc_medi_2$min_length) 

#Let's plot to see the results
prc_medi_length <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_medi_2, aes(x = TPR, y = PPV, colour = min_length)) +
  scale_colour_discrete(
     name = "Min. length (min)") +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on min. length",
       subtitle = "mEDI threshold = 2 lux, max. interrupt = 1 min") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, color = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_medi_length.png",
       plot = prc_medi_length,
       height = 5.5, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw")

```

## Step 3: vary max interruption length 
```{r}
#Create a max_interrupt ranging from 0.5 to 9
max_interrupts <- paste0(seq(0, 9, by = 1), " min")
#From the previous plot, we know that lower mEDI thresholds are better so we keep it to 2
medi_threshold = 2
#We know also know that we shoudl keep the min_lenght to 10 minutes 
min_length = "10 min"


#Empty list to store classification results
prc_m_list <- list()

for (max_interrupt in max_interrupts) {
  
  prc_m_list[[max_interrupt]] <- generate_prc_medi(
    dataset = dataset.LL.wrlg,
    low_medi_var = "MEDI",
    min_length = min_length,
    max_interrupt = max_interrupt,
    medi_threshold = medi_threshold
  )
}

prc_medi_3 <- bind_rows(prc_m_list, .id = "max_interrupt")
#Turning max_interrupt into a factor for plotting
prc_medi_3$max_interrupt <- gsub(" min", "", prc_medi_3$max_interrupt) #first, eliminate the "min"
prc_medi_3$max_interrupt <- as.factor(prc_medi_3$max_interrupt) 

#Let's plot to see the results
prc_medi_interrupt <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_medi_3, aes(x = TPR, y = PPV, colour = max_interrupt)) +
  scale_colour_discrete(
     name = "Max. interrupt (min)") +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on max. interruption",
       subtitle = "mEDI threshold = 2 lux, min. length = 10 min") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, color = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_medi_interrupt.png",
       plot = prc_medi_interrupt,
       height = 5.5, 
       width = 6.3,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw")

```


## One plot with all the three curves 
```{r}

library(cowplot)

multiplot <- cowplot::plot_grid(prc_medi_length, prc_medi_thresholds, prc_medi_interrupt,
                                labels = c("A", "B", "C"),
                                ncol = 3,
                                nrow = 1,
                                align = "hv")

ggsave(filename = "prc_parameters_multiplot.png",
       plot = multiplot,
       width = 16.5, 
       height = 5,
       dpi = 600, 
       bg = "white",
       path = "D:/cyepi/code/outputs/light_activity_prc/raw")


ggplot() +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line 
  xlim(0,1) + 
  ylim(0,1) +
  #plot 1 
  geom_point(data = roc_medi, aes(x = TPR, y = PPV, color = threshold)) + 
   scale_color_continuous(
    limits= c(1,10), breaks = c(2, 4, 6, 8, 10)
  ) +
  ggnewscale::new_scale_colour() + #resets scale for next geom
  #plot 2 
  geom_point(data = roc_minlength, aes(x = TPR, y = PPV, color = min_lengths)) + 
  
  geom_point(data = roc_max_interrupt, aes(x = TPR, y = PPV, color = max_interrupt)) +
  +
 
  
 # scale_color_continuous(
  #limits= c(1,10), breaks = c(2, 4, 6, 8, 10)) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line 
  labs(x="True positive rate",
       y = "Positive predictive value",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds")


```

## Visualising where algorithm goes wrong
Input values: 10 mins lenght, 1 min max. interruption, 2 lux max mEDI value
```{r}
##We want to visualise TP, TN, FP and FN for each participant. We will start doing this for the light data (medicluster_clean)

#First, we need to create state changes from the mediclusters_clean data frame
medi_sc <- mediclusters_clean %>%
  group_by(Id) %>%
  mutate(change = classification != lag(classification, #stores whether classification has changes in a "change" column
                                        default = first(classification))) %>% #need to set default for first value 
  mutate(interval_group =cumsum(change)) %>% #assigns a new interval group every time classification change occurs 
  group_by(Id, interval_group) %>%
  summarise(classification = first(classification), #keep only first value for each Id and interval_group
            xmin = first(Datetime),
            xmax = last(Datetime)) %>%
  ungroup() %>%
  filter(Id == "204")


participant_ids <- unique(clean.LL.wrlg$Id)

selected_id = 204
##Create a for loop to generate a plot for each participant 
for (selected_id in participant_ids) {
subset_df <- dataset.LL.wrlg %>%
  filter(Id == selected_id) %>%
  filter(!State == "sleep") 


##Calculate the limits of the shaded areas according to the Wear Log
alg.times <- medi_sc %>%
  filter(Id == selected_id & !is.na(classification)) %>%
  mutate(xmax = (xmax + lubridate::seconds(10)),
         Day.data.min = xmin %>% format(format = "%a"), #lower limit of the shaded area, needed for geom_rect
         Day.data.max = xmax %>% format(format = "%a"), #upper limit of shaded area, needed for geom_rect
         xmin = xmin %>% hms::as_hms(), #transform xmin to time (currently Datetime)
         xmax = xmax %>% hms::as_hms(), #transform xmax to time (currently Datetime)
         Day.data.min = factor(Day.data.min, levels = unique(Day.data.min)),
         Day.data.max = factor(Day.data.max, levels = unique(Day.data.max)))

##Some intervals on the Wear log that we want to plot cross day boundaries. We thus need to split them in 2 intervals, since we plot each day on a different facet of the plot 

#Step 1: collect the part of the data that does not cross day boundaries
alg.times1 <-
  alg.times %>%
  filter(Day.data.min == Day.data.max)

#Step 2: Collect part of the data that does cross bounderies and split it by day, i.e. at midnight. 
alg.times2 <-
alg.times %>% filter(Day.data.min != Day.data.max) %>%
  rowwise() %>%
  mutate(
    new_entry = list(
      tibble(
        xmin=c(xmin, hms::as_hms("00:00:00")),
        xmax=c(hms::as_hms("23:59:59"), xmax),
        Day.min=c(Day.data.min, Day.data.max),
        Day.max=c(Day.data.min, Day.data.max)
      )
    )
  ) %>%
  select(Id, classification, new_entry) %>%
  unnest(new_entry)

#Step 3: Combine the two again in a single df
alg.combined <- 
  bind_rows(alg.times1 %>% rename(Day.min = Day.data.min),
            alg.times2) %>%
  select(-Day.max) %>%
  rename(Day.data = Day.min) 


#Create the plot wit activity (PIM), button presses (eventpoint) and wearlog intervals (State)

alg.combined$classification <- factor(alg.combined$classification, levels = c("TP", "TN", "FP", "FN")) #turn State into factor


p <- gg_day(data = subset_df, #base plot defaults to plotting mEDI on y axis
            linewidth = 0.05, 
            color = "black", 
            geom = "line",
            format.day = "%a",
            x.axis.label = "Time", 
            y.axis.label = "Illuminance (mEDI, lx)",
            title = paste("p", selected_id, "light levels and algorithm performance")) +
  geom_rect(data=alg.combined, aes(xmin= xmin, xmax = xmax, ymin =0, ymax = Inf, fill = classification), #adding classification output
                    inherit.aes = FALSE,
                    alpha = 0.15) +
    scale_fill_manual(
     name = "Algorithm classification",
     values = c("TP" = "darkgreen",
                "TN" = "#0072B2",
                "FP" = "darkred",
                "FN" = "darkgoldenrod2")) +
  theme(plot.title = element_text(hjust = 0.5, size = 24, face = "plain"),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14))

filename <- paste0("p", selected_id, "algorithm performance (light).png")
ggsave(filename = filename,
       plot = p,
       width = 10,
       height = 14,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/medi_alg_perf")
}
```
## Comments on above graph: it kind of works, but for some reason the shading of intervals that corss midnight does not work. Need to check again how this is done 
