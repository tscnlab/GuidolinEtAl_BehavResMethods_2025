---
title: "bag_activity_prc"
author: "Carolina Guidolin"
date: "2024-07-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Note
This script should be run after files in 01_import and 02_datapreparation have been run. 

# Aim
To know whether we can precisely predict non-wear times (detected by the wear log) using information from the black back use (low mEDI) and/or activity (low PIM). To do this, we build a precision recall curve (PRC).

## Testing steffen's function which indentifies clusters of non-wear time 
These functions (find_clusters_funs, loaded in separately) identify clusters of low illuminance. The following parameters can be selected: 
1) logical values where clusters should be found - in this case, low illuminance or low activity values (below a certain threshold)
2) minimum length of the clusters
3) max interrpution length for the cluster to still be identified as such 

### Loading in the data, if not already there
```{r}
clean.LL.wrlg <- readRDS('clean_data.Rds')
```
#Identifying clusters of low activity (PIM)
```{r}

#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)

#Empty list to store classification results
prc_list <- list()

#Running a for loop to generate a prc for all selected PIM thresholds 
for (threshold in pimthresholds) {
  
  prc_result <- generate_prc(
    dataset = dataset.LL.wrlg,
    low_var = "PIM",
    min_length = 60, #10 minutes (n of observations)
    max_interrupt = 0, #0 minute (n of observations)
    threshold = threshold
  )
  
  # Add the current threshold as a column in prc_result
  prc_result <- prc_result %>%
    mutate(threshold = threshold) # Add threshold column
  
  prc_list[[as.character(threshold)]] <- prc_result
  
}

#Turn into a df
prcurve_pim <- bind_rows(prc_list)

#Turn threshold to numeric for plotting
prcurve_pim$threshold <- as.numeric(prcurve_pim$threshold)

```

## Calculating F1 score
This scores is a metric to evaluate precision and recall. It is calculate as the harmonic mean of precision and recall. The F1 Score is useful when looking for the right balance between high precision and high recall, as it penalizes extreme negative values of either component. In other words, this score 
```{r}

prcurve_pim_f1 <- prcurve_pim %>%
  mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))

```


# Identifying clusters of low light levels (mEDI)
```{r}

medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_list <- list()

for (threshold in medithresholds) {
  
  prc_result <- generate_prc(
    dataset = dataset.LL.wrlg,
    low_var = "MEDI",
    min_length = 60, #10 minutes (n of observations)
    max_interrupt = 0, #0 minute (n of observations)
    threshold = threshold
  )
  
  # Add the current threshold as a column in prc_m_result
  prc_result <- prc_result %>%
    mutate(threshold = threshold) # Add threshold column
  
  prc_list[[as.character(threshold)]] <- prc_result
  
}

#Turn list into df
prcurve_medi <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
prcurve_medi$threshold <- as.numeric(prcurve_medi$threshold)


```


## Calculate F1 score 
```{r}

prcurve_medi_f1 <- prcurve_medi %>%
  mutate(f1_score = (2* PPV * TPR)/(PPV + TPR))

```


# Visualisation of the precision recall curves for activity and light (all participants together)
```{r}

prc_combined <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     low = "blue", high = "lightblue",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5))  +
  ggnewscale::new_scale_color() + #need this to reset the color scale for the next plot
  #Adding the arrow to show directionality (for illuminance)
  geom_segment(aes(x = 0.87,
                   y = 0.74,
                   xend = 0.939,
                   yend = 0.35),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  #Adding the arrow to show directionality (for activity)
  geom_segment(aes(x = 0.61,
                   y = 0.41,
                   xend = 0.74,
                 yend = 0.33),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity \nand illuminance thresholds",
       subtitle = "Min. length = 10 min, max. interruption = 0 min") +
  #Adding the symbols for the arrows as text and the label
  annotate("text",
           x = 0.67,
           y = 0.79,
           label = sprintf('\u2191')) + #arrow pointing upwards for Illuminance
  geom_text(aes(x= 0.83,
                y = 0.78,
                label = "Illuminance")) + #label of illuminance
  annotate("text",
           x = 0.399,
           y = 0.44,
           label = sprintf('\u2191')) + #arrow pointing upwards for activity
  geom_text(aes(x = 0.51,
                y = 0.43,
                label = "Activity")) + #label for activity
  geom_text(aes(x=0.215,
                y = 0.535,
                label = "Baseline classifier"),
            color = "darkgrey",
            size = 3.8) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, colour = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "prc_thresholds_light_pim.png",
       plot = prc_combined,
       height = 5.5, 
       width = 5,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw/general_plots")
```

##Visualisation of activity and light prc for each participant in a multiplot
This is helpful to know whether the prc performs differently in each participant. We also want to know: if our algorithm performs poorly, is it because the participants were not compliant with using the black bag? So, the first step is actually to calculate how often the bag was actually used when logging and off event. 

###Calculating % usage of black bag 
```{r}
 bag_use <- dataset.LL.wrlg %>%
  group_by(Id) %>%
   mutate(bag_use = case_when(
     State == "off" & bag == 0 ~ "notused", #when State is off and bag is 0, it was not used
     State == "off" & bag == 1 ~ "used", #when state is off and bag is 1, it was used
     .default = NA_character_)) %>%
  ungroup()

per_bag_use <- bag_use %>%
  group_by(Id, bag_use) %>% 
  summarise(count = n()) %>% #calculating how many used and notused per participant
  filter(!is.na(bag_use)) %>% #eliminate NAs which correspond to when State is on or sleep
  complete(bag_use = c("used", "notused"), fill = list(count = 0)) %>% #if participant does not have values for "used" or "notused" because they either never used the bag, or always used it, we replace that with 0
  mutate(total = sum(count), #counting total entries per participant
         compliance_per = if_else(bag_use == "used", (count*100)/total, NA), #calculating % of "used" over total entries
         compliance_per = round(compliance_per, 1)) %>% #rounding the percentage value to 1 decimal point
  filter(!is.na(compliance_per)) #eliminate the NA that comes from the ifelse

```

## Plotting the PRC for each participant and labelling % compliance of bag use 
For this, we need to run the prc curves with the correct function (generate_indiv_prc)

## Run this for activity first
```{r}
# Generating prc for each individual using activity 

#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)

#Empty list to store classification results
prc_list <- list()

#Running a for loop to generate a prc for all selected PIM thresholds 
for (threshold in pimthresholds) {
  
  prc_result <- generate_indiv_prc(
    dataset = dataset.LL.wrlg,
    low_var = "PIM",
    min_length = 60, #10 minutes (n of observations)
    max_interrupt = 0, #0 minute (n of observations)
    threshold = threshold
  )
  
  # Add the current threshold as a column in prc_result
  prc_result <- prc_result %>%
    mutate(threshold = threshold) # Add threshold column
  
  prc_list[[as.character(threshold)]] <- prc_result
  
}

#Turn into a df
prcurve_pim_indiv <- bind_rows(prc_list)

#Turn threshold to numeric for plotting
prcurve_pim_indiv$threshold <- as.numeric(prcurve_pim_indiv$threshold)
```

## Run this for illuminance

```{r}

medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_list <- list()

for (threshold in medithresholds) {
  
  prc_result <- generate_indiv_prc(
    dataset = dataset.LL.wrlg,
    low_var = "MEDI",
    min_length = 60, #10 minutes (n of observations)
    max_interrupt = 0, #0 minute (n of observations)
    threshold = threshold
  )
  
  # Add the current threshold as a column in prc_m_result
  prc_result <- prc_result %>%
    mutate(threshold = threshold) # Add threshold column
  
  prc_list[[as.character(threshold)]] <- prc_result
  
}

#Turn list into df
prcurve_medi_indiv <- bind_rows(prc_list)
#Turn threshold to numeric for plotting
prcurve_medi_indiv$threshold <- as.numeric(prcurve_medi_indiv$threshold)
```

## Plotting each participant in a panel
```{r}
prc_multiplot <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim_indiv, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     low = "blue", high = "lightblue",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5)) +
  facet_wrap(~ Id) +
  coord_fixed(ratio = 1) +
  ggnewscale::new_scale_color() +
  #Second plot: light
  geom_point(data = prcurve_medi_indiv, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  facet_wrap(~Id) +
  geom_text(data = per_bag_use, aes(x = 0.15, y = 0.90, label = paste("Bag use:\n",compliance_per,"%")), size = 3.2) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of non-wear intervals based on activity \nand illuminance thresholds",
       subtitle = "Min. length = 10 min, max. interruption = 1 min") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

#Save the plot
ggsave(filename = "medi_pim_multiplot.png",
       plot = prc_multiplot,
       height = 11, 
       width = 11,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw/general_plots")

```

## Visualising where algorithm goes wrong
Input values: 10 mins lenght, 1 min max. interruption, 2 lux max mEDI value
```{r}
##We want to visualise TP, TN, FP and FN for each participant. We will start doing this for the light data (medicluster_clean)

prcurve_medi_clean <- prcurve_medi %>%
  filter(threshold == 1)

#First, we need to create state changes from the mediclusters_clean data frame
medi_sc <- prcurve_medi_clean %>%
 group_by(Id) %>%
 mutate(interval_group = consecutive_id(classification)) %>% #need to set default for first value 
  group_by(Id, interval_group) %>%
  summarise(classification = first(classification), #keep only first value for each Id and interval_group
            xmin = first(Datetime),
            xmax = last(Datetime)) %>%
  ungroup() 


##List of all unique participant IDs
participant_ids <- unique(dataset.LL.wrlg$Id)

##Create a for loop to generate a plot for each participant 
for (selected_id in participant_ids) {
  
 subset_df <- dataset.LL.wrlg %>%
  filter(Id == selected_id)


##Calculate the limits of the shaded areas according to the Wear Log
alg.times <- medi_sc %>%
  filter(Id == selected_id) %>%
  mutate(xmax = (xmax + lubridate::seconds(10)), #need to add 10 seconds to match next start time
         Day.data.min = xmin %>% format(format = "%a"), #lower limit of the shaded area, needed for geom_rect
         Day.data.max = xmax %>% format(format = "%a"), #upper limit of shaded area, needed for geom_rect
         xmin = xmin %>% hms::as_hms(), #transform xmin to time (currently Datetime)
         xmax = xmax %>% hms::as_hms(), #transform xmax to time (currently Datetime)
         Day.data.min = factor(Day.data.min, levels = unique(Day.data.min)),
         Day.data.max = factor(Day.data.max, levels = unique(Day.data.max)))

##Some intervals on the Wear log that we want to plot cross day boundaries. We thus need to split them in 2 intervals, since we plot each day on a different facet of the plot 

#Step 1: collect the part of the data that does not cross day boundaries
alg.times1 <-
  alg.times %>%
  filter(Day.data.min == Day.data.max)

#Step 2: Collect part of the data that does cross bounderies and split it by day, i.e. at midnight. 
alg.times2 <-
alg.times %>% filter(Day.data.min != Day.data.max) %>%
  rowwise() %>%
  mutate(
    new_entry = list(
      tibble(
        xmin=c(xmin, hms::as_hms("00:00:00")),
        xmax=c(hms::as_hms("23:59:59"), xmax),
        Day.min=c(Day.data.min, Day.data.max),
        Day.max=c(Day.data.min, Day.data.max)
      )
    )
  ) %>%
  select(classification, new_entry) %>%
  unnest(new_entry)

#Step 3: Combine the two again in a single df
alg.combined <- 
  bind_rows(alg.times1 %>% rename(Day.min = Day.data.min),
            alg.times2) %>%
  select(-Day.max) %>%
  rename(Day.data = Day.min) 

alg.combined$classification <- factor(alg.combined$classification, levels = c("TP", "TN", "FP", "FN", "NA")) #turn State into factor

#Our dataset contains gaps

p <- gg_day(data = subset_df, #base plot defaults to plotting mEDI on y axis
            linewidth = 0.1, 
            aes_col = State, 
            geom = "line",
            group = date(Datetime),
            format.day = "%a",
            x.axis.label = "Time", 
            y.axis.label = "Illuminance (mEDI, lx)",
            title = paste("p", selected_id, "light levels and algorithm performance")) +
  geom_rect(data=alg.combined, aes(xmin= xmin, xmax = xmax, ymin =0, ymax = Inf, fill = classification), #adding classification output
                    inherit.aes = FALSE,
                    alpha = 0.15) +
    scale_fill_manual(
     name = "Algorithm classification",
     values = c("TP" = "darkgreen",
                "TN" = "#0072B2",
                "FP" = "darkred",
                "FN" = "darkgoldenrod2"),
                na.value = "white") +
  theme(plot.title = element_text(hjust = 0.5, size = 24, face = "plain"),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14))

filename <- paste0("p", selected_id, "algorithm performance_2 (light).png")
ggsave(filename = filename,
       plot = p,
       width = 10,
       height = 14,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs/light_activity_prc/raw/medi_alg_perf")
}
```
## Comments on above graph: it kind of works, but for some reason the shading of intervals that corss midnight does not work. Need to check again how this is done 
