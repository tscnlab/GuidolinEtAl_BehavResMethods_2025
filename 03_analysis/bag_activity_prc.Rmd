---
title: "bag_activity_prc"
author: "Carolina Guidolin"
date: "2024-07-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Note
This script should be run after files in 01_import and 02_datapreparation have been run. 

# Aim
To know whether we can precisely predict non-wear times (detected by the wear log) using information from the black back use (low mEDI) and/or activity (low PIM). To do this, we build a precision recall curve (PRC).

## Testing steffen's function which indentifies clusters of non-wear time 
These functions (find_clusters_funs, loaded in separately) identify clusters of low illuminance. The following parameters can be selected: 
1) logical values where clusters should be found - in this case, low illuminance or low activity values (below a certain threshold)
2) minimum length of the clusters
3) max interrpution length for the cluster to still be identified as such 

### Loading in the data, if not already there
```{r}
clean.LL.wrlg <- readRDS('clean_data.Rds')
```


#Identifying clusters of low activity (PIM)
```{r}
#In order to build a PRC, we need to test the performance of our algorithm by changing the input parameters. Here, we modifiy the threshold for "low activity", i.e. the PIM value. 

#Parameters fed into the function
min_length = 60 #10 minutes of observation, with sampling interval of 10 seconds -> 60 rows
max_interrupt = 6 #1 minute (n of observations)

#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)

#Empty list to store classification results
prc_pim_list <- list()
  
  for (threshold in pimthresholds) {

  pim_clusters <- dataset.LL.wrlg %>%
    ungroup() %>%
   mutate(State = if_else(State == "sleep", NA_real_, State)) %>%  #converting all sleep values to NAs, since we do not want to use these for our classification 
   # Replace `low_activity` by the (logical) variable for which the clusters 
   # should be found.
   mutate(low_pim = PIM < threshold) %>% 
   # Nest by groups, e.g., participant, period. Replace with grouping variables 
   # in your data, such that the function is applied separately per consecutive 
   # timeseries (e.g., from one subject during one period).
    nest_by(Id) %>% 
   mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_pim, 
        min_length = min_length, 
        max_interrupt = max_interrupt, 
        cluster_name = "low_pim_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


  pimclusters_clean <- pim_clusters %>%
   select(Id, Datetime, State, bag, is_low_pim_cluster) %>%
    mutate(
      State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0,
      is.na(State) ~ NA_real_), # keep sleep states as NA,
    is_low_pim_cluster = case_when(
      is_low_pim_cluster == TRUE ~ 0,
      is_low_pim_cluster == FALSE ~ 1
    )) 

#We want to build a precision recall curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

  pimclusters_clean <- pimclusters_clean %>%
   mutate(classification = case_when(
      State == 0 & is_low_pim_cluster == 0 ~ "TP",
      State == 0 & is_low_pim_cluster == 1 ~ "FN",
      State == 1 & is_low_pim_cluster == 0 ~ "FP",
      State == 1 & is_low_pim_cluster == 1 ~ "TN",
     .default = NA_character_))

  prc_pim <- pimclusters_clean %>%
    group_by(Id, classification) %>% ##!!If you want to visualise info per participatn, you also have to group_by Id. Else, only by classification
   summarise(count = n())  %>%
   pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
    mutate(TPR = TP/(TP+FN), #this is the formula for TPR (true positive rate)
           FPR = FP/(FP+TN), #this is the formula for the FPR (false positive rate)
           PPV = TP/(TP+FP), #positive predictive value
          NPV = TN/(FN+TN), #negative predictive values
           threshold = threshold)  #adding manually which threshold I am considering here 

  #Add the result to the list
   prc_pim_list[[as.character(threshold)]] <- prc_pim
  }

#Turn the list with the results into a df 
prcurve_pim <- bind_rows(prc_pim_list)

#Turn thresholds from character to factor for plotting
prcurve_pim$threshold <- as.numeric(prcurve_pim$threshold)

```

## Visualising prc for activity only

```{r}
prc_all_ids <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "PIM threshold (lx)",
     low = "blue", high = "lightblue",
     limits= c(5,50),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity thresholds",
       subtitle = "Min. length = 10 min, max. interruption = 1 min") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, colour = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "10min-index-prc-raw.png",
       plot = prc_all_ids,
       height = 11, 
       width = 11,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/general_plots")


```

## Calculating F1 score
```{r}
b = 1 #set beta as 1

prcurve_pim_f1 <- prcurve_pim %>%
  mutate(f1_score = ((1+b^2) * PPV * TPR)/((b^2 * PPV) + TPR))

#Again, precision is low (PPV), indicating that there are instances where our classifier labels non-wear but actually the participant was wearing it. 

# Recall also saturates, meaning that the proportion of non-wear that our classifier can detect does not change with different activity levels. Meaning no matter the activity that participant has, our model does not change performance based on.

#If we increase our range of thresholds of PIM (5 to 500), the recall gets better with increasing activity threshold. Meaning that there are probably instances when the participants are walking around with it in a bag. 
```


# Identifying clusters of low light levels (mEDI)
```{r}
#Similarly to above, we create a series of thresholds that will be fed into the function and be used to build the prc 
medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_medi_list <- list()
min_length = 6 #10 minutes of observation, with sampling interval of 10 seconds -> 60 rows
max_interrupt = 0 #1 minute of observations, with sampling interval being 10 seconds

threshold = 1


for (threshold in medithresholds) {

medi_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  mutate(State = if_else(State == "sleep", NA_character_, State)) %>% #converting all sleep values to NAs, since we do not want to use these for our classification 
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = min_length, 
        max_interrupt = max_interrupt, 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


mediclusters_clean <- medi_clusters %>%
  select(Id, Datetime, State, MEDI, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0,
      is.na(State) ~ NA_real_), # keep sleep states as NA 
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    )) 

#We want to build a precision recall curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

mediclusters_clean <- mediclusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

prc_medi <- mediclusters_clean %>%
  group_by(classification) %>% #!! if you want to visualise individual PRC, then you have to group_by(Id, classification). Else, only group_by(classification)
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
  mutate(TPR = TP/(TP+FN), #true positive rate
         FPR = FP/(FP+TN), #false positive rate
         PPV = TP/(TP+FP), #positive predictive value
         NPV = TN/(FN+TN), #negative predictive value
         threshold = threshold)  #adding manually which threshold I am considering here 

 #Add the result to the list
  prc_medi_list[[as.character(threshold)]] <- prc_medi
}

#Turn the list with the results into a df 
prcurve_medi <- bind_rows(prc_medi_list)

#Turn thresholds from character to factor for plotting
prcurve_medi$threshold <- as.numeric(prcurve_medi$threshold)

```


#Calculate F1 score to understand the agreement between my precision and recall
```{r}
b = 1 #set beta as 1

prcurve_medi_f1 <- prcurve_medi %>%
  mutate(f1_score = ((1+b^2) * PPV * TPR)/((b^2 * PPV) + TPR))

##With increasing medi levels, the recall (TPR) remains virtually identical, suggesting that the proportion of all non-wear identified correctly does not change (proportion of true non-wear compared to all non-wear) -> meaning that we are capturing all the non-wear that our classifier can capture, and changing on threshold in not changing 

#However, the precision (PPV) - proportion of non-wear labels was actually non-wear, gets worse, meaning we get more false positives because we are being more liberal in what we label as non-wear state.

#
```


#Visualisation of prc for light only
```{r}
prc_all_ids <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on illuminance thresholds",
       subtitle = "Min. length = 1 min, max. interruption = 0 min") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, colour = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "10min-index-light-raw.png",
       plot = prc_all_ids,
       height = 11, 
       width = 11,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/general_plots")


```


# Visualisation of the precision recall curves for activity and light (all participants together)
```{r}

prc_combined <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5))  +
  ggnewscale::new_scale_color() + #need this to reset the color scale for the next plot
  #Adding the arrow to show directionality (for illuminance)
  geom_segment(aes(x = 0.87,
                   y = 0.74,
                   xend = 0.939,
                   yend = 0.35),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  #Adding the arrow to show directionality (for activity)
  geom_segment(aes(x = 0.61,
                   y = 0.41,
                   xend = 0.74,
                 yend = 0.33),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity \nand illuminance thresholds",
       subtitle = "Min. length = 10 min, max. interruption = 1 min") +
  #Adding the symbols for the arrows as text and the label
  annotate("text",
           x = 0.63,
           y = 0.79,
           label = sprintf('\u2191')) + #arrow pointing upwards for Illuminance
  geom_text(aes(x= 0.80,
                y = 0.78,
                label = "Illuminance")) + #label of illuminance
  annotate("text",
           x = 0.389,
           y = 0.44,
           label = sprintf('\u2191')) + #arrow pointing upwards for activity
  geom_text(aes(x = 0.50,
                y = 0.43,
                label = "Activity")) + #label for activity
  geom_text(aes(x=0.215,
                y = 0.535,
                label = "Baseline classifier"),
            color = "darkgrey",
            size = 3.8) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 14, colour = "grey33"),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "prc_thresholds_light_pim.png",
       plot = prc_combined,
       height = 5.5, 
       width = 5,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/general_plots")
```

##Visualisation of activity and light prc for each participant in a multiplot
This is helpful to know whether the prc performs differently in each participant. We also want to know: if our algorithm performs poorly, is it because the participants were not compliant with using the black bag? So, the first step is actually to calculate how often the bag was actually used when logging and off event. 

###Calculating % usage of black bag 
```{r}
 bag_use <- dataset.LL.wrlg %>%
  group_by(Id) %>%
   mutate(bag_use = case_when(
     State == "off" & bag == 0 ~ "notused", #when State is off and bag is 0, it was not used
     State == "off" & bag == 1 ~ "used", #when state is off and bag is 1, it was used
     .default = NA_character_)) %>%
  ungroup()

per_bag_use <- bag_use %>%
  group_by(Id, bag_use) %>% 
  summarise(count = n()) %>% #calculating how many used and notused per participant
  filter(!is.na(bag_use)) %>% #eliminate NAs which correspond to when State is on or sleep
  complete(bag_use = c("used", "notused"), fill = list(count = 0)) %>% #if participant does not have values for "used" or "notused" because they either never used the bag, or always used it, we replace that with 0
  mutate(total = sum(count), #counting total entries per participant
         compliance_per = if_else(bag_use == "used", (count*100)/total, NA), #calculating % of "used" over total entries
         compliance_per = round(compliance_per, 1)) %>% #rounding the percentage value to 1 decimal point
  filter(!is.na(compliance_per)) #eliminate the NA that comes from the ifelse

```

###Plotting the PRC for each participant and labelling % compliance of bag use 
For this, you need to modify the prc code above (for both PIM and MEDI) to group_by (Id, classification). See line 251.
```{r}
prc_multiplot <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
     low = "blue", high = "lightblue",
     limits= c(5,50),
    guide = guide_colorbar(title.position = "top",
                           title.hjust = 0.5)) +
  facet_wrap(~ Id) +
  coord_fixed(ratio = 1) +
  ggnewscale::new_scale_color() +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  facet_wrap(~Id) +
  geom_text(data = per_bag_use, aes(x = 0.15, y = 0.90, label = paste("Bag use:\n",compliance_per,"%")), size = 3.2) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of non-wear intervals based on activity \nand illuminance thresholds",
       subtitle = "Min. length = 10 min, max. interruption = 1 min") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
   coord_fixed(ratio = 1)

#Save the plot
ggsave(filename = "10min-multiplot.png",
       plot = prc_multiplot,
       height = 11, 
       width = 11,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/general_plots")

```


## Visualising where algorithm goes wrong
Input values: 10 mins lenght, 1 min max. interruption, 2 lux max mEDI value
```{r}
##We want to visualise TP, TN, FP and FN for each participant. We will start doing this for the light data (medicluster_clean)

#First, we need to create state changes from the mediclusters_clean data frame
medi_sc <- mediclusters_clean %>%
 group_by(Id) %>%
 mutate(interval_group = consecutive_id(classification)) %>% #need to set default for first value 
  group_by(Id, interval_group) %>%
  summarise(classification = first(classification), #keep only first value for each Id and interval_group
            xmin = first(Datetime),
            xmax = last(Datetime)) %>%
  ungroup() 


##List of all unique participant IDs
participant_ids <- unique(dataset.LL.wrlg$Id)

##Create a for loop to generate a plot for each participant 
for (selected_id in participant_ids) {
  
 subset_df <- dataset.LL.wrlg %>%
  filter(Id == selected_id)


##Calculate the limits of the shaded areas according to the Wear Log
alg.times <- medi_sc %>%
  filter(Id == selected_id) %>%
  mutate(xmax = (xmax + lubridate::seconds(10)), #need to add 10 seconds to match next start time
         Day.data.min = xmin %>% format(format = "%a"), #lower limit of the shaded area, needed for geom_rect
         Day.data.max = xmax %>% format(format = "%a"), #upper limit of shaded area, needed for geom_rect
         xmin = xmin %>% hms::as_hms(), #transform xmin to time (currently Datetime)
         xmax = xmax %>% hms::as_hms(), #transform xmax to time (currently Datetime)
         Day.data.min = factor(Day.data.min, levels = unique(Day.data.min)),
         Day.data.max = factor(Day.data.max, levels = unique(Day.data.max)))

##Some intervals on the Wear log that we want to plot cross day boundaries. We thus need to split them in 2 intervals, since we plot each day on a different facet of the plot 

#Step 1: collect the part of the data that does not cross day boundaries
alg.times1 <-
  alg.times %>%
  filter(Day.data.min == Day.data.max)

#Step 2: Collect part of the data that does cross bounderies and split it by day, i.e. at midnight. 
alg.times2 <-
alg.times %>% filter(Day.data.min != Day.data.max) %>%
  rowwise() %>%
  mutate(
    new_entry = list(
      tibble(
        xmin=c(xmin, hms::as_hms("00:00:00")),
        xmax=c(hms::as_hms("23:59:59"), xmax),
        Day.min=c(Day.data.min, Day.data.max),
        Day.max=c(Day.data.min, Day.data.max)
      )
    )
  ) %>%
  select(classification, new_entry) %>%
  unnest(new_entry)

#Step 3: Combine the two again in a single df
alg.combined <- 
  bind_rows(alg.times1 %>% rename(Day.min = Day.data.min),
            alg.times2) %>%
  select(-Day.max) %>%
  rename(Day.data = Day.min) 

alg.combined$classification <- factor(alg.combined$classification, levels = c("TP", "TN", "FP", "FN", "NA")) #turn State into factor

#Our dataset contains gaps

p <- gg_day(data = subset_df, #base plot defaults to plotting mEDI on y axis
            linewidth = 0.1, 
            aes_col = State, 
            geom = "line",
            group = date(Datetime),
            format.day = "%a",
            x.axis.label = "Time", 
            y.axis.label = "Illuminance (mEDI, lx)",
            title = paste("p", selected_id, "light levels and algorithm performance")) +
  geom_rect(data=alg.combined, aes(xmin= xmin, xmax = xmax, ymin =0, ymax = Inf, fill = classification), #adding classification output
                    inherit.aes = FALSE,
                    alpha = 0.15) +
    scale_fill_manual(
     name = "Algorithm classification",
     values = c("TP" = "darkgreen",
                "TN" = "#0072B2",
                "FP" = "darkred",
                "FN" = "darkgoldenrod2"),
                na.value = "white") +
  theme(plot.title = element_text(hjust = 0.5, size = 24, face = "plain"),
        axis.text.x = element_text(size = 16),
        axis.title = element_text(size = 18),
        axis.text.y = element_text(size = 16),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14))

filename <- paste0("p", selected_id, "algorithm performance_2 (light).png")
ggsave(filename = filename,
       plot = p,
       width = 10,
       height = 14,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs/light_activity_prc/raw/medi_alg_perf")
}
```
## Comments on above graph: it kind of works, but for some reason the shading of intervals that corss midnight does not work. Need to check again how this is done 
