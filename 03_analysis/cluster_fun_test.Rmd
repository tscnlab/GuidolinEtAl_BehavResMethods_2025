---
title: "function_test"
output: html_document
date: "2024-10-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Generating a df similar to the one I have
The data frame contains the following columns:
1. 2 Ids (101, 102, 103)
2. Datetime timestamps (around 6 days per participant, with sampling interval 10 seconds)
3. MEDI: random numbers, with some high values and some vaulues between 0 and 2 (ensuring some clusters would be detected)
```{r}
# Load necessary libraries
library(dplyr)

set.seed(123)  # For reproducibility
n_ids <- 3  # Number of unique Ids
ids <- c(101, 102, 203)
start_dates <- as.POSIXct(c("2023-08-01 00:00:00", "2023-08-02 00:00:00", "2023-08-03 00:00:00"))
n_days <- 6  # Approximate duration in days per Id
frequency <- 10  # 10-second interval in seconds

# Function to generate data for a single ID
generate_data_for_id <- function(id, start_date, n_days, frequency) {
  n_rows <- n_days * 24 * 60 * 60 / frequency  # Number of rows based on days and frequency
  datetimes <- seq(from = start_date, by = frequency, length.out = n_rows)
 # Generate MEDI values:
  # 80% of values between 200-300
  # 15% of values between 0-2
  # 5% of values between 1000-2000
  medi_values <- c(
    rnorm(n_rows * 0.8, mean = 250, sd = 50), # Majority in 200-300 range
    runif(n_rows * 0.15, min = 0, max = 2), # Small values between 0 and 2
    runif(n_rows * 0.05, min = 1000, max = 2000)# Occasional high values
  )
  
  # Ensure all MEDI values are non-negative
  medi_values <- pmax(medi_values, 0)
  
  # Randomise the MEDI values within each group
  medi_values <- sample(medi_values)
  
  data.frame(Id = id, Datetime = datetimes, MEDI = medi_values)
}

# Generate data for each Id and combine
data_list <- lapply(1:n_ids, function(i) {
  generate_data_for_id(ids[i], start_dates[i], n_days, frequency)
})
dummy_data <- bind_rows(data_list)

```

## Apply the data_find_clusters function
Parameters fed into the function:
1. Low MEDI threshold of 2 lux
2. Minimum length of the cluster should be 10 minutes
3. Max interruption of MEDI > 2 lux within the cluster should be 1 minute
```{r}
#Apply the cluster detection function 
threshold = 2
min_length = "10 mins"
max_interrupt = "1 mins"

medi_clusters <- dummy_data %>%
  ungroup() %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = min_length, 
        max_interrupt = max_interrupt, 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()
```

## Checking the duration of the low medi clusters 
```{r}
#Let's just do this for one participant, e.g. 101
selected_id = 101

cluster_dur <- medi_clusters %>%
  filter(Id == selected_id) %>%
  mutate(grp = consecutive_id(is_low_medi_cluster)) %>%
  group_by(grp) %>%
  slice(1) %>% # keep first row
  ungroup %>%  # don't need grouping anymore
  mutate(cluster_length = difftime(Datetime, lag(Datetime), units="mins")) %>% #calculate the differences between a row and previous one (lag(n=1))
  filter(is_low_medi_cluster == TRUE) #filter for the low medi clusters only

#Checking whether there are clusters that are less than 10 mins 
check_dur <- cluster_dur %>%
  filter(cluster_length < "10 mins")

#Visualising this with an histogram
ggplot(check_dur, aes(cluster_length)) +
  geom_histogram(bins = 50)
```

