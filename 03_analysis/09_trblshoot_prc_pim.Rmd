---
title: "trblshoot_prc"
output: html_document
date: "2024-10-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Fine tuning the input parameters for finding clusters of low illuminance
In this script, we produce precision-recall curves for each input parameter of the data_find_cluster function, in order to understand which parameters will work better to detect clusters of low activity. The data_find_cluster function takes three input parameters:
1. A minimum length of the interval
2. A threshold for the activity values (PIM)
3. A maximum interruption of the interval for values that are above threshold

In the chunks that follow, we vary each of these three parameters while keeping the other constant.

### First, import functions - if not in the environment yet
```{r}
# Function to identify clusters
base::source(here::here("03_analysis", "functions", "find_clusters_fun.R"))

#Function to generate aggregate pr curve
base::source(here::here("03_analysis", "functions", "generate_prc_funs.R"))
```

## Step 1: vary minimum length of interval 
Activity threshold and maximum interruption stay the same
```{r}
#Create min_length ranging from 1 to 30 minutes, with 1 minute steps
min_lengths <- seq(6, 180, by = 6)

# Make the assumptions that lower PIM levels would be best
pim_threshold = 5

#We keep the max_interrupt at 0 minutes
max_interrupt = 0 #0 minutes


#Empty list to store classification results
prc_m_list <- list()

#Running a for loop that creates a prc for all selected min_lengths 
for (min_length in min_lengths) {
  
  prc_result <- generate_prc(
    dataset = df.LL.nosleep,
    low_var = "PIM",
    min_length = min_length,
    max_interrupt = max_interrupt,
    threshold = pim_threshold
  )
  
  # Add the current min_length as a column in prc_m_result
  prc_result <- prc_result %>%
    mutate(min_length = min_length) # Add min_length column
  
  prc_m_list[[as.character(min_length)]] <- prc_result
}

#Turning list into a df 
prc_pim_1 <- bind_rows(prc_m_list)

#Turning min_length into a factor for plotting
prc_pim_1$min_length <- as.factor(prc_pim_1$min_length) 

#Calculate F1 score
prcpim1_fscore <- prc_pim_1 %>%
  mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))

#Let's plot to see the results
prc_pim_length <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_pim_1, aes(x = TPR, y = PPV, colour = min_length)) +
  scale_colour_discrete(
     name = "Min. length (min)",
     labels = seq(1, 30, by = 1)
     ) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Minimum length \nbased detection") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        plot.margin = unit(c(0.5,0.5,0,0), unit ="cm")) +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_pim_length_30.png",
       plot = prc_pim_length,
       height = 5.5, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= here::here("outputs", "supplementary"))

prcpim1_fscore %>% slice_max(f1_score) # highet F1 score at min_length value of 72 = 12 minutes
```
## What does this tell us?
The higher the minimum length, the higher the precision, with the precision values seemingly reaching a plateau at approximately 20 minutes. Higher precision also comes at a cost of a lower recall values. The best minimum length (i.e. highest F1 score) is at min_length = 72, i.e. 12 minutes. 


## Step 2: vary PIM thresholds
Minimum interval length and maximum interruption remain constant.
```{r}

#Create a sequence of PIM thresholds at 5 unit steps
pimthresholds <- c(5,10, 15, 20, 25, 30, 35, 40, 45, 50)

#Empty list to store classification results
prc_m_list <- list()

#Running a for loop to generate a prc for all selected PIM thresholds 
for (threshold in pimthresholds) {
  
  prc_result <- generate_prc(
    dataset = df.LL.nosleep,
    low_var = "PIM",
    min_length = 72, #12 minutes (n of observations) - see step 1
    max_interrupt = 0, #0 minutes (n of observations)
    threshold = threshold
  )
  
  # Add the current threshold as a column in prc_m_result
  prc_result <- prc_result %>%
    mutate(threshold = threshold) # Add threshold column
  
  prc_m_list[[as.character(threshold)]] <- prc_result
  
}

#Turn into a df
prc_pim_2 <- bind_rows(prc_m_list)

#Turn threshold to numeric for plotting
prc_pim_2$threshold <- as.numeric(prc_pim_2$threshold)

#Calculate F1 score
prcpim2_fscore <- prc_pim_2 %>%
  mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))

#Let's plot to see what the result looks like
prc_pim_thresholds <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_pim_2, aes(x = TPR, y = PPV, colour = threshold)) +
  scale_colour_gradient(
     name = "PIM threshold",
     low = "blue", high = "lightblue",
     limits= c(5,50),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Activity threshold \nbased detection") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        plot.margin = unit(c(0.5,0.5,0,0), unit ="cm")) +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_pim_thresholds_12.png",
       plot = prc_pim_thresholds,
       height = 5.5, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= here::here("outputs", "supplementary"))

```

## What does this tell us?
Compared to higher activity threshold values, lower activity thresholds of 5 (PIM) lead to higher precision (i.e. n of non-wear labels correctly assigned), but lower recall (n of non-wear labels assigned among all the non-wear instances). For example, the recall for PIM = 5 is 0.6032611 compared to 0.7385074 for PIM = 50, but the precision follows the opposite trend (0.4525959 for PIM=5 and 0.3721392 for PIM=50).

## Step 3: vary max interruption length 
```{r}
#Create a max_interrupt ranging from 0 to 10 minutes, with 1-minute steps
max_interrupts <- seq(0, 60, by = 6) 

#From the first plot, we know that lower PIM thresholds are better so we keep it to 5
pim_threshold = 5

#We know also know that we should keep the min_length to 12 minutes 
min_length = 72 # 12 minutes (n observations)


#Empty list to store classification results
prc_m_list <- list()

for (max_int in max_interrupts) {
  
  prc_result <- generate_prc(
    dataset = df.LL.nosleep,
    low_var = "PIM",
    min_length = min_length,
    max_int = max_int,
    threshold = pim_threshold
  )
  
  # Add the current max_interrupt as a column in prc_result
  prc_result <- prc_result %>%
    mutate(max_int = max_int) # Add max_interrupt column
  
  prc_m_list[[as.character(max_int)]] <- prc_result
}

#Turn this list into a df 
prc_pim_3 <- bind_rows(prc_m_list)

#Turning max_int into a factor for plotting
prc_pim_3$max_int <- as.factor(prc_pim_3$max_int) 

#Calculate F1 score
prcpim3_fscore <- prc_pim_3 %>%
  mutate(f1_score = (2 * PPV * TPR)/(PPV + TPR))

#Let's plot to see the results
prc_pim_interrupt <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  geom_point(data = prc_pim_3, aes(x = TPR, y = PPV, colour = max_int)) +
  scale_colour_discrete(
     name = "Max. interrupt (min)",
     labels = seq(0, 10, by = 1)
     ) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Maximum interruption \nbased detection") +
   theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        plot.margin = unit(c(0.5,0.5,0,0), unit ="cm")) +
   coord_fixed(ratio = 1)

ggsave(filename = "prc_pim_interrupt_12.png",
       plot = prc_pim_interrupt,
       height = 5.5, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= here::here("outputs", "supplementary"))

```

## What does this tell us?
Varying the maximum interval does not seem to change the precision and the recall of the cluster detection function. 

## One plot with all the three curves 
```{r}

library(cowplot)

multiplot <- cowplot::plot_grid(prc_pim_length, prc_pim_interrupt, prc_pim_thresholds,
                                labels = c("A", "B", "C"),
                                ncol = 3,
                                nrow = 1,
                                align = "hv")

ggsave(filename = "pim_prc_parameters_multiplot_12.png",
       plot = multiplot,
       width = 14, 
       height = 6,
       dpi = 600, 
       bg = "white",
       path = here::here("outputs", "supplementary"))

```

## Visualising F1 score as a function of the min length for both activity and illuminance
Note that for this plot you will need to have run 08_trblshoot_prc_medi.Rmd. 
```{r}
# Turn min length into numeric
prcpim1_fscore$min_length <- as.numeric(prcpim1_fscore$min_length)
prcmedi1_fscore$min_length <- as.numeric(prcmedi1_fscore$min_length)

# Create a new column for coloring the highest F1 score
prcpim1_fscore$highlight <- ifelse(prcpim1_fscore$f1_score == max(prcpim1_fscore$f1_score), "highlight", "normal")
prcmedi1_fscore$highlight <- ifelse(prcmedi1_fscore$f1_score == max(prcmedi1_fscore$f1_score), "highlight", "normal")

# Plot activity
minlength_f1_activity <- ggplot() + 
  geom_point(data = prcpim1_fscore, aes(x=min_length, y=f1_score, colour = highlight)) +
  ylim(0,1) +
  scale_x_continuous(
    breaks = seq(1, 30, by=1),
    labels = c("1", rep("", 8),
               "10", rep("", 9),
               "20", rep("", 9),
               "30")
  ) +
  labs(x = "Min. length (minutes)",
       y = "F1 score [0-1]",
       title = "Activity",
       subtitle = "PIM threshold = 5, \nmax interruption = 0 minutes") +
  coord_fixed(ratio = 50) +
  theme_bw() +
  theme(plot.subtitle=element_text(colour="darkgrey")) +
  scale_color_manual(values = c("highlight" = "red", "normal" = "black"),
                     guide = "none") +
  ggpubr::rremove("xylab")

# Plot illuminance
minlength_f1_illuminance <- ggplot() + 
  geom_point(data = prcmedi1_fscore, aes(x=min_length, y=f1_score, colour = highlight)) +
  ylim(0,1) +
  scale_x_continuous(
    breaks = seq(1, 30, by=1),
    labels = c("1", rep("", 8),
               "10", rep("", 9),
               "20", rep("", 9),
               "30")
  ) +
  labs(x = "Min. length (minutes)",
       y = "F1 score [0-1]",
       title = "Illuminance",
       subtitle = "mEDI threshold = 1, \nmax interruption = 0 minutes") +
  coord_fixed(ratio = 50) +
  theme_bw() +
  theme(plot.subtitle=element_text(colour="darkgrey")) +
  scale_color_manual(values = c("highlight" = "red", "normal" = "black"),
                     guide = "none") +
  ggpubr::rremove("xylab")

# Arrange the two plots
activity_illuminance_f1 <- ggpubr::ggarrange(minlength_f1_illuminance, minlength_f1_activity,
                                             ncol = 2,
                                             nrow = 1, 
                                             widths = c(1,1),
                                             heights = c(1,1),
                                             align = "hv")

activity_illuminance_f1_labelled <- ggpubr::annotate_figure(activity_illuminance_f1,
                                                            top = text_grob("F1 score based on min. cluster length",
                                                            color = "black",
                                                            face = "plain",
                                                            size = 16,
                                                            hjust = 0.5),
                                            left = text_grob("F1 score [0-1]",
                                                             size = 12,
                                                             rot = 90,
                                                             hjust = 0.6),
                                            bottom = text_grob("Min. length (minutes)",
                                                               size = 12,
                                                               hjust = 0.5))

# Save plot
ggsave(filename = "activity_illuminance_f1_labelled.png",
       plot = activity_illuminance_f1_labelled,
       height = 4.8, 
       width = 5,
       dpi = 600,
       bg = "white",
       path= here::here("outputs", "supplementary"))
```