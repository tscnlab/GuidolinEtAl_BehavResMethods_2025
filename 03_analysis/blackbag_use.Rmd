---
title: "blackbag_use"
author: "Carolina Guidolin"
date: "2024-05-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Use of black bag (low illuminance values) to detect non-wear time

Here we analyse data from black bag use (low illuminance [mEDI] values). The first thing that we want to do is a visual inspection of the data to check how light and activity compare, for each State of the Wear log. Low activity is also often used as a way to understand non-wear time in field studies. Since we have both information (light and activity), we want to know how these two source compare to each other. 

```{r}
#We will be plotting using log10 transformation, so we want to replace 0 values for mEDI (light) and PIM (activity) to very low values

dataset.LL.wrlg$MEDI[dataset.LL.wrlg$MEDI == 0] <- 0.00001
dataset.LL.wrlg$PIM[dataset.LL.wrlg$PIM == 0] <- 0.00001

#TO be able to visually observe how light and activity relate to each other in our dataset, we cannot plot all our datapoints (too many). So, we take median values of each Id, for each State (off/on/sleep)

median.LL.wrlg <- dataset.LL.wrlg %>%
  group_by(Id, State) %>%
  summarise(median_medi = median(log10(MEDI), na.rm = TRUE),
            median_pim = median(log10(PIM), na.rm = TRUE),
            qr1_medi = quantile(log10(MEDI), 1/4, na.rm = TRUE), #first quantile
            qr1_pim = quantile(log10(PIM), 1/4, na.rm = TRUE), #first quantile
            qr3_medi = quantile(log10(MEDI), 3/4, na.rm = TRUE), #third quantile
            qr3_pim = quantile(log10(PIM), 3/4, na.rm = TRUE)) %>% #third quantile
  ungroup()

#Let's create a simple scatterplot where median mEDI and PIM are plotted against each other, including error bars
median_scatter <- 
  ggplot(median.LL.wrlg, aes(x = median_medi, y = median_pim, color = State, fill = State)) +
  geom_point() +
    #position = position_jitter(width = 0.5, height = 0.5)) 
 # xlim(-5, 2.5) +
 # ylim(0, 750) +
  scale_fill_manual(
    values = c("off" = "#16439C", "on" = "palegreen4", "sleep" = "darkgoldenrod2")) +
  scale_color_manual(
    values = c("off" = "#16439C", "on" = "palegreen4", "sleep" = "darkgoldenrod2")) +
  labs(title = "Relationship between light and activity", x = "mEDI", y = "PIM") +
  geom_errorbar(aes(ymin = qr1_pim, ymax = qr3_pim)) +
  geom_errorbarh(aes(xmin = qr1_medi, xmax = qr3_medi)) +
  theme_minimal() +
  scale_x_continuous(transform = "symlog")
1
#For the states sleep and off, there are a lot of overlapping points, which is why only a few points are shows. While this plot shows that we have a lot of variability, especially in PIM, we can't really say much about the individual datapoints. 

```


```{r}
#To improve the visualisation above, we can create a simple scatterplot without error bars, and add boxplots as marginal plots

scatter <- ggplot(median.LL.wrlg, aes(x = median_medi, y = median_pim)) + 
  geom_jitter(aes(fill = State, color = State), size = 2.5, alpha = 0.6,
              position = position_jitter(width = .3, height = .3)) + #adjust position of points to avoid overlap
   scale_fill_manual(
    name = "Wear log \n'state'",
    values = c("off" = "darkred", "on" = "#0072B2", "sleep" = "darkgoldenrod2"),
    labels = c("Wake 'off'", "Wake 'on'", "Sleep 'off'")) +
  scale_color_manual(
    name = "Wear log \n'state'",
    values = c("off" = "darkred", "on" = "#0072B2", "sleep" = "darkgoldenrod2"),
    labels = c("Wake 'off'", "Wake 'on'", "Sleep 'off'")) +
  scale_x_continuous(
    breaks = c(-5, -3, -1, 1, 3), 
    labels = c(expression(10^-5), expression(10^-3), expression(10^-1), expression(10^1), expression(10^3)), #ensure that the log expression is labelled correctly 
    limits = c(-5.5, 3)
  ) +
  scale_y_continuous(
    breaks = c(-5, -3, -1, 1, 3),
    labels = c(expression(10^-5), expression(10^-3), expression(10^-1), expression(10^1), expression(10^3)), #ensure that the log expression is labelled correctly 
    limits = c(-5.5, 3)
  ) +
  labs(x = "Median illuminance (mEDI, lx)",
       y = "Activity (PIM)") +
  coord_fixed(ratio=1) + #make sure plot is a square
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 16),
        legend.title = element_text(size = 13, hjust = 0.5),
        legend.text = element_text(size = 13),
        legend.position = "bottom") +
  guides(fill = guide_legend(nrow = 1))
  
#Add a boxpot as a marginal plot using package ggExtra
library(ggExtra)

marginal <- ggExtra::ggMarginal(scatter, type = "boxplot", groupColour = TRUE, groupFill = TRUE)


plot_marginal <- annotate_figure(marginal,
                                 #Add title
                                 top = text_grob("Relationship between illuminance \nand activity across wear log states",
                                                            color = "black",
                                                            face = "plain",
                                                            size = 18))

ggsave(filename = "plot_marginal.svg",
       plot = plot_marginal ,
       width = 5,
       height = 6.5,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs")

```



```{r}
#Another alternative visualisation would be to simply plot mEDI, without activity, across the Wear log states
library(ggdist)

ggplot(data = median.LL.wrlg, aes(x=median_medi, y = State, fill = State)) +
  ggdist::stat_halfeye(
    aes(colour = State,
        fill = State),
    adjust = .5,
    justification = -.25,
    point_color = NA,
    interval_color = NA
    ) +
  geom_boxplot(
    aes(color = State),
    width = .3,
    alpha = .2,
    outlier.shape = NA
  ) +
  geom_jitter(
    aes(colour = State),
    fill = "white",
    height = .1,
    alpha = .3,
    size = 1.2
  ) +
  scale_fill_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_color_manual(
    values = c("on" = "#0072B2", "off" = "darkred", "sleep" = "darkgoldenrod2")) +
  scale_y_discrete(labels = c("on" = "Wake 'on'", "off" = "Wake 'off'", "sleep" = "Sleep 'off'")) +
  theme_ggdist() +
  ggpubr::rremove("ylab") +
  ggpubr::rremove("y.ticks") +
 # ggpubr::rremove("xlab")+ 
  labs(title = "(Non-)wear time distribution across the week", x = "Illuminance (mEDI, lx)") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 16),
        axis.title = element_text(size = 18),
        legend.title = element_text(size = 13),
        legend.text = element_text(size = 13))


#This does not seem to work very well, probably because our sample has too many duplicates of low values 

```

##Testing steffen's function which indentifies clusters of non-wear time 
These functions (find_clusters_funs, loaded in separately) identify clusters of low illuminance. The following parameters can be selected: 
1) logical values where clusters should be found - in this case, low illuminance values (below a certain threshold)
2) minimum length of the clusters
3) max interrpution length for the cluster to still be identified as such 
```{r}

pimthresholds <- seq(5, 50, by = 5)

#Empty list to store classification results
prc_pim_list <- list()

for (threshold in pimthresholds) {

pim_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_pim = PIM < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_pim, 
        min_length = "2 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_pim_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


pimclusters_clean <- pim_clusters %>%
  select(Id, Datetime, State, is_low_pim_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_pim_cluster = case_when(
      is_low_pim_cluster == TRUE ~ 0,
      is_low_pim_cluster == FALSE ~ 1
    )) 

#We want to build a Receiver Operating Curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

pimclusters_clean <- pimclusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_pim_cluster == 0 ~ "TP",
    State == 0 & is_low_pim_cluster == 1 ~ "FN",
    State == 1 & is_low_pim_cluster == 0 ~ "FP",
    State == 1 & is_low_pim_cluster == 1 ~ "TN",
    .default = NA_character_))

prc_pim <- pimclusters_clean %>%
  group_by(classification) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
  mutate(TPR = TP/(TP+FN), #this is the formula for TPR (true positive rate)
         FPR = FP/(FP+TN), #this is the formula for the FPR (false positive rate)
         PPV = TP/(TP+FP), #positive predictive value
         NPV = TN/(FN+TN), #negative predictive values
         threshold = threshold)  #adding manually which threshold I am considering here 

 #Add the result to the list
  prc_pim_list[[as.character(threshold)]] <- prc_pim
}

#Turn the list with the results into a df 
prcurve_pim <- bind_rows(prc_pim_list)

#Turn thresholds from character to factor for plotting
prcurve_pim$threshold <- as.numeric(prcurve_pim$threshold)

```

#We now do the same thing for light
```{r}
medithresholds <- seq(1, 10, by = 1)

#Empty list to store classification results
prc_medi_list <- list()

for (threshold in medithresholds) {

medi_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < threshold) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = "2 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


mediclusters_clean <- medi_clusters %>%
  select(Id, Datetime, State, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    )) 

#We want to build a precision recall curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 1), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

mediclusters_clean <- mediclusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

prc_medi <- mediclusters_clean %>%
  group_by(classification) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count, values_fill = list(count=0)) %>%
  mutate(TPR = TP/(TP+FN), #true positive rate
         FPR = FP/(FP+TN), #false positive rate
         PPV = TP/(TP+FP), #positive predictive value
         NPV = TN/(FN+TN), #negative predictive values
         threshold = threshold)  #adding manually which threshold I am considering here 

 #Add the result to the list
  prc_medi_list[[as.character(threshold)]] <- prc_medi
}

#Turn the list with the results into a df 
prcurve_medi <- bind_rows(prc_medi_list)

#Turn thresholds from character to factor for plotting
prc_medi_list$threshold <- as.numeric(prc_medi_list$threshold)
```

#Now we want to plot both precision recall curves together
```{r}


precision_recall_3 <- ggplot() +
   xlim(0,1) + 
   ylim(0,1) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line which represents a baseline classifier
  #First plot: activity
  geom_point(data = prcurve_pim, aes(x = TPR, y = PPV, color = threshold)) +
   scale_color_gradient(
     name = "Activity threshold (PIM)",
    limits= c(5,50),
    guide = guide_colorbar(title.position = "top", title.hjust = 0.5))  +
  ggnewscale::new_scale_color() + #need this to reset the color scale for the next plot
  #Adding the arrow to show directionality (for illuminance)
  geom_segment(aes(x = 0.6, y = 0.54, xend = 0.63, yend = 0.27),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  #Second plot: light
  geom_point(data = prcurve_medi, aes(x = TPR, y = PPV, colour = threshold)) +
   scale_colour_gradient(
     name = "mEDI threshold (lx)",
     low = "red", high = "orange",
     limits= c(1,10),
     guide = guide_colourbar(title.position = "top", title.hjust = 0.5)) +
  #Adding the arrow to show directionality (for activity)
  geom_segment(aes(x = 0.49, y = 0.165, xend = 0.57, yend = 0.115),
               arrow = arrow(length=unit(.2, "cm")), lwd = 0.8) +
  labs(x="True positive rate (recall)",
       y = "Positive predictive value \n(precision)",
       title = "Precision-recall curve for detection of \nnon-wear intervals based on activity \nand illuminance thresholds") +
  #Adding the symbols for the arrows as text and the label
  annotate("text", x = 0.64, y = 0.45, label = sprintf('\u2191')) + #arrow pointing upwards for Illuminance
  geom_text(aes(x= 0.80, y = 0.445, label = "Illuminance")) + #label of illuminance
  annotate("text", x = 0.28, y = 0.14, label = sprintf('\u2191')) + #arrow pointing upwards for activity
  geom_text(aes(x = 0.39, y = 0.135, label = "Activity")) + #label for activity
  geom_text(aes(x=0.215, y = 0.535, label = "Baseline classifier"), color = "darkgrey", size = 3.8) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 8),
        legend.key.size = unit(4, "mm"),
        legend.position = "bottom",
        legend.box = "horizontal") +
  coord_fixed(ratio = 1) 

#Save the plot
ggsave(filename = "precision_recall_3.svg",
       plot = precision_recall_3,
       height = 5.5, 
       width = 5,
       dpi = 600,
       bg = "white",
       path= "G:/cyepi/code/outputs")
```


```{r}
library(plotROC)
library(pROC)

medi10lux_clusters <- dataset.LL.wrlg %>%
  ungroup() %>%
  filter(!State == "sleep") %>%
  # Replace `low_activity` by the (logical) variable for which the clusters 
  # should be found.
  mutate(low_medi = MEDI < 10) %>% 
  # Nest by groups, e.g., participant, period. Replace with grouping variables 
  # in your data, such that the function is applied separately per consecutive 
  # timeseries (e.g., from one subject during one period).
  nest_by(Id) %>% 
  mutate(
    # Replace `low_activity` by the (logical) variable for which the clusters 
    # should be found.
    data = list(
      data_find_clusters(
        data, 
        low_medi, 
        min_length = "2 mins", 
        max_interrupt = "1 mins", 
        cluster_name = "low_medi_cluster"
      )
    )
  ) %>%
  unnest(cols = data) %>%
  ungroup()


medi10lux_clusters_clean <- medi10lux_clusters %>%
  select(Id, Datetime, State, is_low_medi_cluster) %>%
  mutate(
    State = case_when(
      State == "on" ~ 1, 
      State == "off" ~ 0),
    is_low_medi_cluster = case_when(
      is_low_medi_cluster == TRUE ~ 0,
      is_low_medi_cluster == FALSE ~ 1
    ))

#We want to build a Receiver Operating Curve for our classifier algorithm, which, based o our "Ground truth", i.e. the wear log state values (on = 1 and off = 0), classifies the performance of our algorithm for detecting non-wear as follows:
#1) State = 0, cluster = 0 -> true positive
#2) State = 0, cluster = 1 -> false negative
#3) State = 1, cluster = 1 -> false positive
#4) State = 1, cluster = 0 -> true negative

medi10lux_clusters_clean <- medi10lux_clusters_clean %>%
  mutate(classification = case_when(
    State == 0 & is_low_medi_cluster == 0 ~ "TP",
    State == 0 & is_low_medi_cluster == 1 ~ "FN",
    State == 1 & is_low_medi_cluster == 0 ~ "FP",
    State == 1 & is_low_medi_cluster == 1 ~ "TN",
    .default = NA_character_))

roc_10medi <- medi10lux_clusters_clean %>%
  group_by(classification) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = classification, values_from = count) %>%
  mutate(TPR = TP/(TP+FN),
         FPR = FP/(FP+TN),
         PPV = TP/(TP+FP),
         NPV = TN/(FN+TN),
         threshold = threshold)  #adding manually which mEDI threshold I am considering here 
#  select(TPR, FPR, threshold) %>%
      


roc_curve10 <- roc(data = medi10lux_clusters_clean,
                  response = is_low_medi_cluster,
                  predictor = State,
                  levels = c(control = 1, case = 0))

ggroc(roc_curve10)

```


```{r}
generate_roc_medi <- function(dataset, low_medi_var, min_length, max_interrupt, medi_threshold) {
  medi_clusters <- dataset %>%
    ungroup() %>%
    filter(!State == "sleep") %>%
    mutate(low_medi = !!rlang::sym(low_medi_var) < medi_threshold) %>%
    nest_by(Id) %>%
    mutate(
      data = list(
        data_find_clusters(
          data, 
          low_medi, 
          min_length = min_length, 
          max_interrupt = max_interrupt, 
          cluster_name = "low_medi_cluster"
        )
      )
    ) %>%
    unnest(cols = data) %>%
    ungroup()
  
  mediclusters_clean <- medi_clusters %>%
    select(Id, Datetime, State, is_low_medi_cluster) %>%
    mutate(
      State = case_when(
        State == "on" ~ 1, 
        State == "off" ~ 0),
      is_low_medi_cluster = case_when(
        is_low_medi_cluster == TRUE ~ 0,
        is_low_medi_cluster == FALSE ~ 1
      )
    )
  
  mediclusters_clean <- mediclusters_clean %>%
    mutate(classification = case_when(
      State == 0 & is_low_medi_cluster == 0 ~ "TP",
      State == 0 & is_low_medi_cluster == 1 ~ "FN",
      State == 1 & is_low_medi_cluster == 0 ~ "FP",
      State == 1 & is_low_medi_cluster == 1 ~ "TN",
      .default = NA_character_
    ))
  
  roc_medi <- mediclusters_clean %>%
    group_by(classification) %>%
    summarise(count = n()) %>%
    pivot_wider(names_from = classification, values_from = count, values_fill = list(count = 0)) %>%
    mutate(
      TPR = TP / (TP + FN),
      FPR = FP / (FP + TN),
      PPV = TP / (TP + FP),
      NPV = TN / (FN + TN),
      medi_threshold = medi_threshold #note: this has to be changed every time based on which variable you are varying
    )
  
  return(roc_medi)
}


```


#Now, we vary one parameter: mEDI values 
```{r}
# Step 1: vary mEDI thresholds
thresholds <- seq(1, 10, by = 1)
roc_medi <- map(thresholds, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = "2 mins",
  max_interrupt = "1 mins",
  medi_threshold = .x
))

names(roc_medi) <- as.character(thresholds)
roc_medi <- bind_rows(roc_medi)


medi_thresholds <- ggplot(roc_medi, aes(x = TPR, y = PPV)) +
  geom_point(aes(color = threshold)) +
  xlim(0,1) + 
  ylim(0,1) +
  scale_color_continuous(
    limits= c(1,10), breaks = c(2, 4, 6, 8, 10)
  ) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat degree line 
  labs(x="True positive rate (recall)",
       y = "Positive predictive value (precision)",
       title = "Precision recall curve for detection \nof non-wear intervals based on illuminance thresholds") +
  guides(
    color = guide_colorbar(
    title = "mEDI threshold (lx)",
    nbin = 10,
    reverse = TRUE)) +
  theme_bw() +
  coord_fixed(ratio = 1)

ggsave(filename = "medi_thresholds.png",
       plot = medi_thresholds,
       height = 6, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs")

```




```{r}
# Step 2: vary length of interval 
min_lengths <- paste0(seq(1, 10, by = 1), " min")
roc_minlength <- map(min_lengths, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = .x,
  max_interrupt = "1 mins",
  medi_threshold = 4
))

names(roc_minlength) <- min_lengths
roc_minlength <- bind_rows(roc_minlength)

roc_minlength$min_length <- gsub(" min", "", roc_minlength$min_length)
roc_minlength$min_length <- as.factor(roc_minlength$min_length)

min_length <- ggplot(roc_minlength, aes(x = TPR , y = PPV)) +
  geom_point(aes(color = min_length)) +
  xlim(0,1) + 
  ylim(0,1) +
  scale_color_discrete(
    name = "Minimum length (mins)") +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a 45 degree line 
  labs(x="True positive rate (recall)",
       y = "Positive predictive value (precision)",
       title = "Precision recall curve for detection \nof non-wear interval based on interval length")  +
  theme(plot.title = element_text(hjust=0.5)) +
  theme_bw() +
  coord_fixed(ratio = 1)

ggsave(filename = "min_length.png",
       plot = min_length,
       height = 6, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs")
```

```{r}
# Step 3: vary max interruption length 
max_interrupt <- paste0(seq(1, 10, by = 1), " min")
roc_max_interrupt<- map(max_interrupt, ~ generate_roc_medi(
  dataset = dataset.LL.wrlg,
  low_medi_var = "MEDI",
  min_length = "2 mins",
  max_interrupt = .x,
  medi_threshold = 4
))

names(roc_max_interrupt) <- max_interrupt
roc_max_interrupt <- bind_rows(roc_max_interrupt)

roc_max_interrupt$max_interrupt <- gsub(" min", "", roc_max_interrupt$max_interrupt)
roc_max_interrupt$max_interrupt <- as.factor(roc_max_interrupt$max_interrupt)

max_interrupt <- ggplot(roc_max_interrupt, aes(x = TPR, y = PPV )) +
  geom_point(aes(color = max_interrupt)) +
  xlim(0,1) + 
  ylim(0,1) +
 scale_color_discrete(
    name = "Maximum interruption (mins)") +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line 
  labs(x="True positive rate (recall)",
       y = "Positive predictive value (precision)",
       title = "Precision recall curve for detection \nof non-wear interval based on interruption length")  +
  theme(plot.title = element_text(hjust=0.5)) +
  theme_bw() +
  coord_fixed(ratio = 1)

ggsave(filename = "max_interrupt.png",
       plot = max_interrupt,
       height = 6, 
       width = 6,
       dpi = 600,
       bg = "white",
       path= "D:/cyepi/code/outputs")

```


#One plot with all the curves 
```{r}

library(cowplot)

multiplot <- cowplot::plot_grid(medi_thresholds, min_length, max_interrupt,
                               ncol = 3,
                               nrow = 1,
                               align = "hv")

ggsave(filename = "PCR_multiplot.png",
       plot = multiplot,
       width = 16, 
       height = 5,
       dpi = 600, 
       bg = "white",
       path = "D:/cyepi/code/outputs")



library(ggnewscale)

ggplot() +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line 
  xlim(0,1) + 
  ylim(0,1) +
  #plot 1 
  geom_point(data = roc_medi, aes(x = TPR, y = PPV, color = threshold)) + 
   scale_color_continuous(
    limits= c(1,10), breaks = c(2, 4, 6, 8, 10)
  ) +
  ggnewscale::new_scale_colour() + #resets scale for next geom
  #plot 2 
  geom_point(data = roc_minlength, aes(x = TPR, y = PPV, color = min_lengths)) + 
  
  geom_point(data = roc_max_interrupt, aes(x = TPR, y = PPV, color = max_interrupt)) +
  +
 
  
 # scale_color_continuous(
  #limits= c(1,10), breaks = c(2, 4, 6, 8, 10)) +
  geom_abline(slope = 0, intercept = 0.5, linetype = "dashed", color = "darkgrey") + #add a flat line 
  labs(x="True positive rate",
       y = "Positive predictive value",
       title = "ROC curve for automatic detection \nof non-wear based on different mEDI thresholds")


```

```{r}
#Trying out if low activity is a better classifier that light 
```

